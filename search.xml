<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HPE综述</title>
    <url>/post/f4697f57/</url>
    <content><![CDATA[<h1 id="Monocular-Human-Pose-Estimation-A-Survey-of-Deep-Learning-based-Methods"><a href="#Monocular-Human-Pose-Estimation-A-Survey-of-Deep-Learning-based-Methods" class="headerlink" title="Monocular Human Pose Estimation: A Survey of Deep Learning-based Methods"></a>Monocular Human Pose Estimation: A Survey of Deep Learning-based Methods</h1><h2 id="HPE-类别"><a href="#HPE-类别" class="headerlink" title="HPE 类别"></a>HPE 类别</h2><ol>
<li>generative（human body model-based)：<br>人体模型结构作为先验，几何上从不同视角投影到二位或三维空间，高维参数空间用回归的方式优化</li>
<li>discriminative (human body model-free)<br>从输入源直接学习一个映射，或者搜索现有案例(不用人体模型)；更快但是对没有训练过的姿态健壮性不足<span id="more"></span></li>
</ol>
<hr>
<p>多人pose estimation</p>
<ol>
<li><p>top-down<br>先探测人，产生位置的bounding box</p>
</li>
<li><p>bottom-up</p>
<p>先预测每个人所有的身体部位，再用人体模型拟合或者其他算法进行分组</p>
<p>当人变多时top-down计算花费明显提高，但如果有大规模的重叠，bottom-up方法在重组肢体上可能会遇到问题</p>
</li>
</ol>
<hr>
<ol>
<li><p>regression-based<br>直接从输入图片map关节坐标，或则得到人体模型参数</p>
</li>
<li><p>dectection-based(中间生成关节位置图像块或热图)   </p>
<p>将身体部位当作探测目标依据两个经常使用概念：关节部位的图像块和热图</p>
<p>小区域表示鲁棒性更强；小区域的检测结果限制了最终关节坐标的精度</p>
</li>
</ol>
<hr>
<ol>
<li><p>one-stage</p>
</li>
<li><p>multi-stage</p>
<p>有中间监督；例如先检测人的位置再顾及人体姿势</p>
<p>3D的HPE先在2d表面预测关节位置再将它们拓展到3D空间</p>
</li>
</ol>
<h3 id="人体模型"><a href="#人体模型" class="headerlink" title="人体模型"></a>人体模型</h3><p>一个成熟的人体模型不必包含所有身体特征，但是需要满足构建和描述人体姿势的特殊任务的需求</p>
<ol>
<li><p>骨架模型</p>
<p>代表一系列的关节位置和相应的遵从人体骨架结构的肢体方向</p>
<p>也可以描述为一个图，顶点代表关节，用边代表骨架结构中关节的链接和约束</p>
</li>
<li><p>轮廓模型</p>
<p>早期用的比较多</p>
</li>
<li><p>体模型</p>
<p>早期是圆锥圆柱，现在都用mesh</p>
</li>
</ol>
<hr>
<h2 id="2D人体姿态估计"><a href="#2D人体姿态估计" class="headerlink" title="2D人体姿态估计"></a>2D人体姿态估计</h2><h3 id="2D单人姿态估计"><a href="#2D单人姿态估计" class="headerlink" title="2D单人姿态估计"></a>2D单人姿态估计</h3><ol>
<li>先检测出单人，依据标注的人的中心位置和身体比例从原始图像中剪裁</li>
<li>regression-based 方法通过一个端到端的框架直接学习和预测坐标位置</li>
<li>detection-based方法先通过学习关节的或身体部位的矩形框，或者热图(每个都通过一个一关节位置为中心的2D高斯分布来显式一个关节位置)预测出身体部位的大致位置，再进行回归</li>
<li>Soft-argmax函数能将热图转化为关节坐标；将一个dectection-based网络变成一个可微分的回归网络</li>
</ol>
<h4 id="Regression-based-methods"><a href="#Regression-based-methods" class="headerlink" title="Regression-based methods"></a>Regression-based methods</h4><p>直接回归出坐标，缺点太多</p>
<h4 id="Detection-based-methods"><a href="#Detection-based-methods" class="headerlink" title="Detection-based methods"></a>Detection-based methods</h4><p>每个关节占据一个热图通道用一个一目标关节位置为中心的2D高斯分布</p>
<p>因为热图表示比坐标表示更有鲁棒性，大部分最近的研究都基于热图表示</p>
<p>有大量的工作在做这个方向</p>
<hr>
<h2 id="2D多人姿态估计"><a href="#2D多人姿态估计" class="headerlink" title="2D多人姿态估计"></a>2D多人姿态估计</h2><p>需要同时进行detection和localization</p>
<h3 id="Top-down-methods"><a href="#Top-down-methods" class="headerlink" title="Top-down methods"></a>Top-down methods</h3><p>效果依赖人体目标检测的结果，速度较慢，大都是非实时的</p>
<h3 id="Bottom-up-methods"><a href="#Bottom-up-methods" class="headerlink" title="Bottom-up methods"></a>Bottom-up methods</h3><p>需要进行joint dection和joint candiate grouping</p>
<p>速度快，但是容易收到复杂背景和人体遮挡的影响</p>
<p>stoa是top-down但是速度慢</p>
<hr>
<h2 id="3D人体姿态估"><a href="#3D人体姿态估" class="headerlink" title="3D人体姿态估"></a>3D人体姿态估</h2><p>单眼相机应用非常广泛，深度神经网络有能力预测dense depth和sparse depth points</p>
<h3 id="model-free-methods"><a href="#model-free-methods" class="headerlink" title="model-free methods"></a>model-free methods</h3><ol>
<li>直接将图片映射到3D位置</li>
<li>从预测的2D姿态上接着预测深度信息</li>
</ol>
<h3 id="Model-based-methods"><a href="#Model-based-methods" class="headerlink" title="Model-based methods"></a>Model-based methods</h3><ol>
<li>有很多工作基于SMPL(一个人体模型)，估计人体3D参数</li>
<li>运动学模型的运用也很广泛</li>
<li>还有自监督学习（可以研究的一个方向)</li>
<li>latent 3D pose model</li>
</ol>
<hr>
<h2 id="3D多人姿态估计"><a href="#3D多人姿态估计" class="headerlink" title="3D多人姿态估计"></a>3D多人姿态估计</h2><ol>
<li>研究方向很新工作较少</li>
<li>大都是多阶段</li>
</ol>
<hr>
<h2 id="数据集和评估指标"><a href="#数据集和评估指标" class="headerlink" title="数据集和评估指标"></a>数据集和评估指标</h2><h3 id="2D人体姿态估计数据集"><a href="#2D人体姿态估计数据集" class="headerlink" title="2D人体姿态估计数据集"></a>2D人体姿态估计数据集</h3><ol>
<li>FILC</li>
<li>LSP</li>
<li>MPII</li>
<li>COCO</li>
<li>AIC-HKD</li>
<li>Penn Action</li>
<li>J-HMDB</li>
<li>PoseTrack</li>
</ol>
<h3 id="2D人体姿态估计评价指标"><a href="#2D人体姿态估计评价指标" class="headerlink" title="2D人体姿态估计评价指标"></a>2D人体姿态估计评价指标</h3><ol>
<li><p>Percentage of Correct Parts(PCP)</p>
</li>
<li><p>Percentage of Correct Keypoints(PCK)</p>
</li>
<li><p>AP</p>
<p>每个点是单独算precision的，最后算所有点的平均</p>
</li>
<li><p>GFLOPs(速度)</p>
</li>
</ol>
<hr>
<h3 id="3D人体姿态估计数据集"><a href="#3D人体姿态估计数据集" class="headerlink" title="3D人体姿态估计数据集"></a>3D人体姿态估计数据集</h3><ol>
<li><p>HumanEva-I&amp;IIDatasets</p>
<p>有采集的3D坐标</p>
</li>
<li><p>Human3.6Mdataset</p>
</li>
<li><p>TNT15 Dataset</p>
</li>
<li><p>MPI-INF-3DHP</p>
</li>
<li><p>TotalCapture Dataset</p>
</li>
<li><p>MARCOnI Dataset(乱)</p>
</li>
<li><p>Panoptic Dataset</p>
</li>
<li><p>3DPW Dataset</p>
</li>
</ol>
<h3 id="3D人体姿态估计的评价指标"><a href="#3D人体姿态估计的评价指标" class="headerlink" title="3D人体姿态估计的评价指标"></a>3D人体姿态估计的评价指标</h3><ol>
<li>Mean Per Joint Positon Error(MPJPE)</li>
<li>PCK和AUC</li>
</ol>
]]></content>
      <categories>
        <category>HPE</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>CV</tag>
        <tag>python</tag>
        <tag>survey</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode4.10</title>
    <url>/post/a1bc9d56/</url>
    <content><![CDATA[<h3 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90.子集II"></a><span id="more"></span>90.子集II</h3><p>提示：去重不要忘记排序，一定要<strong>先排序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">track_back</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> startIndex,vector&lt;<span class="keyword">bool</span>&gt; &amp;used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i<span class="number">-1</span>]==nums[i]&amp;&amp;used[i<span class="number">-1</span>]==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="built_in">track_back</span>(nums,i+<span class="number">1</span>,used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">track_back</span>(nums,<span class="number">0</span>,used);</span><br><span class="line">        result.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h3><p>提示：要注意这道题和上面题的区别，这道题要求递增序列所以我们不能对它进行排序，那怎么层间去重呢，我们可以用一个set，记录同一层内相同元素是否被取用过，若其被取用过，就跳过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; ivec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ivec.<span class="built_in">size</span>()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;ivec.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ivec[i]&gt;ivec[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; iset;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iset.<span class="built_in">find</span>(nums[i])!=iset.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            iset.<span class="built_in">insert</span>(nums[i]);          </span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(path))&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">backtrack</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;        </span><br><span class="line">        <span class="built_in">backtrack</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="46排列问题"><a href="#46排列问题" class="headerlink" title="46排列问题"></a>46排列问题</h3><p>提示：排列问题的关键在于记录已经用过的元素，如果这个元素已经用过了，就不再使用这个元素了，我们可以用一个used数组来记录，也可以用直接在遍历的时候判断其是否已经在path中了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;nums,vector&lt;<span class="keyword">bool</span>&gt;&amp;used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtrack</span>(nums,used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums,used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="47-全排列2"><a href="#47-全排列2" class="headerlink" title="47.全排列2"></a>47.全排列2</h3><p>提示：注意层间去重复的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;nums,vector&lt;<span class="keyword">bool</span>&gt;&amp;used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;used[i<span class="number">-1</span>]==<span class="literal">false</span>)&#123;<span class="comment">//只有used[i-1]== 0是才能说明函数返回到了同一层</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtrack</span>(nums,used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums,used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode4.2</title>
    <url>/post/fb6d090d/</url>
    <content><![CDATA[<h3 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59.螺旋矩阵"></a><span id="more"></span>59.螺旋矩阵</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">result</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>)); <span class="comment">//一个放数字的二位数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> loop = n/<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop--)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = flag;j&lt;(n-flag<span class="number">-1</span>);j++)&#123;</span><br><span class="line">              result[flag][j] = count++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = flag;i&lt;(n-flag<span class="number">-1</span>);i++)&#123;</span><br><span class="line">              result[i][n<span class="number">-1</span>-flag] = count++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = (n<span class="number">-1</span>-flag);j&gt;flag;j--)&#123;</span><br><span class="line">              result[n<span class="number">-1</span>-flag][j] = count++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = (n<span class="number">-1</span>-flag);i&gt;flag;i--)&#123;</span><br><span class="line">              result[i][flag] = count++;</span><br><span class="line">          &#125;</span><br><span class="line">          flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            result[n/<span class="number">2</span>][n/<span class="number">2</span>] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><p>提示：用滑动窗口的方法，滑动窗口的有效性证明已经做过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = INT32_MAX;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//滑动窗口数值之和</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//滑动窗口起始位置</span></span><br><span class="line">        <span class="keyword">int</span> subLenth = <span class="number">0</span>; <span class="comment">//滑动窗口的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                subLenth = (j-i+<span class="number">1</span>);</span><br><span class="line">                result = result &lt; subLenth ? result:subLenth;</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span>: result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode * next;</span><br><span class="line">  <span class="built_in">ListNode</span>(<span class="keyword">int</span> i):<span class="built_in">val</span>(i),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;; <span class="comment">//因为自定义了一个构造函数，没有合成的默认构造函数了</span></span><br></pre></td></tr></table></figure>



<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p>提示：可以采用虚拟节点的方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode * virhead = <span class="keyword">new</span>  <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="keyword">auto</span> pre = virhead;</span><br><span class="line">        <span class="keyword">auto</span> cur = virhead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == val)&#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> virhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    LinkNode * next;</span><br><span class="line">    <span class="built_in">LinkNode</span>(<span class="keyword">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    LinkNode * head = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>()&#123;</span><br><span class="line">        size = <span class="number">0</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            p = p-&gt;next;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> newnode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        newnode-&gt;next = head;</span><br><span class="line">        head = newnode;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> newnode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        p-&gt;next = newnode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">addAtHead</span>(val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index&lt;size)&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = head;</span><br><span class="line">            <span class="keyword">auto</span> loop = index<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(loop--)&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> newnode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">            newnode-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = newnode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == size)&#123;</span><br><span class="line">            <span class="built_in">addAtTail</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;=<span class="number">0</span>&amp;&amp;index&lt;size)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index ==<span class="number">0</span>)&#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> p = head;</span><br><span class="line">                <span class="keyword">auto</span> loop = index<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(loop--)&#123;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>提示：采用pre和cur两个指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        ListNode * pre = <span class="literal">nullptr</span>; <span class="comment">//pre是nullptr，因为第一个也要翻转</span></span><br><span class="line">        <span class="keyword">auto</span> cur = head; <span class="comment">//cur需要从head开始，因为第一个也需要反转</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur  = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>提示：采用快慢指针，先移动n个单位，再两者同时移动</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> pre = head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode4.5</title>
    <url>/post/65099cae/</url>
    <content><![CDATA[<h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a><span id="more"></span>454.四数相加II</h3><p>思路：用一个unordered map将A和B所有相加的结果存起来，key是相加的结果，value是次数，然后遍历C+D查这个map，若有-(C+D)就把result加上出现次数，遍历完成则循环结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B, vector&lt;<span class="keyword">int</span>&gt;&amp; C, vector&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map1;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;B.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                map1[A[i]+B[j]]++;</span><br><span class="line">                map2[C[i]+D[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = map1.<span class="built_in">begin</span>();iter != map1.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = map2.<span class="built_in">find</span>(-iter-&gt;first);</span><br><span class="line">            <span class="keyword">if</span>(p != map2.<span class="built_in">end</span>())&#123;</span><br><span class="line">                result += p-&gt;second*iter-&gt;second ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="383赎金信"><a href="#383赎金信" class="headerlink" title="383赎金信"></a>383赎金信</h3><p>提示：这一题非常类似242题有效的字母异位词，也是用一个数组记录A中出现的字母个数，再遍历B，遇到相应的字母就-1；0-1就变成负数也无所谓，最后看数组中是否有大于0的；若是有就返回false</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">my_set</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ransomNote)&#123;</span><br><span class="line">            my_set[i-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:magazine)&#123;</span><br><span class="line">            my_set[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_if</span>(my_set.<span class="built_in">begin</span>(),my_set.<span class="built_in">end</span>(),[](<span class="keyword">int</span> i )&#123;</span><br><span class="line">            <span class="keyword">return</span> i&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;) == my_set.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h3><p>提示：本题正常需要三重循环，我们用两重循环+双指针的方法来降低复杂度，但是要注意去重的位置，不满足条件的时候去不去重都无所谓</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector &lt;vector&lt;<span class="keyword">int</span>&gt;&gt; my_set;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//i的去重复</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[left]+nums[right]+nums[i];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    my_set.<span class="built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++; <span class="comment">//left的去重</span></span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right<span class="number">-1</span>]) right--; <span class="comment">//right的去重</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> my_set;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="18-四数字之和"><a href="#18-四数字之和" class="headerlink" title="18.四数字之和"></a>18.四数字之和</h3><p>提示：这道题与三数之和非常类似，一定要学会这种去重的方法，具体看代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;nums.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span> &amp;&amp; nums[k] == nums[k<span class="number">-1</span>])&#123; <span class="comment">//去重；之所以写k&gt;0是因为第一个不能去</span></span><br><span class="line">                <span class="keyword">continue</span>;       </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = k+<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;k+<span class="number">1</span>&amp;&amp;nums[i] == nums[i<span class="number">-1</span>])&#123; <span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left= i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(right&gt;left)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[k]+nums[i]+nums[left]+nums[right]&gt;target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[k]+nums[i]+nums[left]+nums[right]&lt;target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(&#123;nums[k],nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left+<span class="number">1</span>] == nums[left]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right<span class="number">-1</span>]== nums[right]) right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--; </span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="344-翻转字符串"><a href="#344-翻转字符串" class="headerlink" title="344.翻转字符串"></a>344.翻转字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j= s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode4.3</title>
    <url>/post/8c6a399b/</url>
    <content><![CDATA[<h3 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="142.环形链表"></a><span id="more"></span>142.环形链表</h3><p>提示：找入环点 2(x+y) = x+y+y+z,得出x=z，从head和相遇处同时出发，再相遇的位置的就是入环点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next== <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> fast = head;</span><br><span class="line">        <span class="keyword">auto</span> slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">auto</span> index1 = fast;</span><br><span class="line">                <span class="keyword">auto</span> index2 = head;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p>提示：采用哈希表的方法储存出现次数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">         record[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">         record[t[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">auto</span> p = <span class="built_in">find_if</span>(<span class="built_in">begin</span>(record),<span class="built_in">end</span>(record),[](<span class="keyword">const</span> <span class="keyword">int</span>&amp; i)&#123;</span><br><span class="line">            <span class="keyword">return</span> i != <span class="number">0</span>;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">if</span>(p == <span class="built_in">end</span>(record))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h3><p>提示：将一个数组放到哈希表中，然后遍历另一个数组查表，将能查到的放到一个vector中，注意将vector去重复的操作(还有一个方法是把结果放到set里，也不会重复)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="keyword">int</span>&gt; <span class="title">table</span><span class="params">(nums1.begin(),nums1.end())</span></span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(table.<span class="built_in">find</span>(i) != table.<span class="built_in">end</span>())&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">unique</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        result.<span class="built_in">erase</span>(p,result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h3><p>提示：每次得到一个值如果不是1就将其放入哈希表中，如果这个值再次出现则说明有重复现象的出现，直接返回false</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//得到一个各个数字位的方法</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            sum += (n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">            n /=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; iset;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(iset.<span class="built_in">find</span>(sum) == iset.<span class="built_in">end</span>())&#123;</span><br><span class="line">                iset.<span class="built_in">insert</span>(sum);</span><br><span class="line">                n = sum;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p>提示：一次循环将要找的结果找到，同时将自己加到map里,注意find找的是key_value，所以要将值作为key，将位置作为value</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; imap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = imap.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter != imap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            imap.<span class="built_in">insert</span>(&#123;nums[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode4.6</title>
    <url>/post/fc00cd14/</url>
    <content><![CDATA[<h3 id="541-翻转字符串II"><a href="#541-翻转字符串II" class="headerlink" title="541.翻转字符串II"></a><span id="more"></span>541.翻转字符串II</h3><p>提示：在循环中控制每次翻转开始的地方</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i+=(<span class="number">2</span>*k))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+k<span class="number">-1</span> &lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i,s.<span class="built_in">begin</span>()+i+k);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i,s.<span class="built_in">begin</span>()+s.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer 05.替换空格"></a>剑指offer 05.替换空格</h3><p>提示：见到数组字符串的替换，就可以用双指针的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sOldSize =  s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(<span class="number">2</span>*count+sOldSize);</span><br><span class="line">        <span class="keyword">int</span> j = sOldSize<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s[i--] = s[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s[i--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[i--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[i--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p>提示：首先要去除多余空格(用一个双指针法去除空格)，然后每个单词做翻转，最后整体再翻转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//去掉字符串前面的空格</span></span><br><span class="line">        <span class="keyword">while</span>(fast&lt;s.<span class="built_in">size</span>()&amp;&amp;s[fast] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;fast&lt;s.<span class="built_in">size</span>();fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast<span class="number">-1</span>&gt;<span class="number">0</span>&amp;&amp;s[fast<span class="number">-1</span>]==s[fast]&amp;&amp;s[fast]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s[slow++] = s[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(slow<span class="number">-1</span>&gt;<span class="number">0</span>&amp;&amp;s[slow<span class="number">-1</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            s.<span class="built_in">resize</span>(slow<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s.<span class="built_in">resize</span>(slow);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> word_size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j!=s.<span class="built_in">size</span>()&amp;&amp;s[j] != <span class="string">&#x27; &#x27;</span>;j++)&#123;</span><br><span class="line">                word_size++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i,s.<span class="built_in">begin</span>()+i+word_size);</span><br><span class="line">            i = i+word_size+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="总结使用双指针的题目"><a href="#总结使用双指针的题目" class="headerlink" title="总结使用双指针的题目"></a>总结使用双指针的题目</h2><p>只要是移除元素或者替换元素的方法都可以用双指针</p>
<p>替换元素要先resize到合适的大小再从后向前遍历如上面剑指offer的第5题</p>
<p>三数之和和四数之和的问题关键在先排序，外面用循环控制，里面用双指针查找满足条件的解，注意：去重复的方法，外部去重不要把第一个去掉，内部去重再找到符合条件的之后再去重</p>
<h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p>提示：采用双栈法，当输出栈为空时，将输入栈的东西全部倒进去</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; in_stack;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; out_stack;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        in_stack.<span class="built_in">push</span>(x);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out_stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!in_stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            out_stack.<span class="built_in">push</span>(in_stack.<span class="built_in">top</span>());</span><br><span class="line">            in_stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = out_stack.<span class="built_in">top</span>();</span><br><span class="line">        out_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        out_stack.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in_stack.<span class="built_in">empty</span>()&amp;&amp;out_stack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h3><p>提示：重点是用另外一个队列保存前面的元素，当pop( )完成后把这个队列的内容还回去，别忘了把第二个队列清零</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        que1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = que1.<span class="built_in">front</span>();</span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">        que1 = que2;</span><br><span class="line">        <span class="keyword">while</span>(!que2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode4.7</title>
    <url>/post/8b07fd82/</url>
    <content><![CDATA[<h3 id="20-有效的括号匹配"><a href="#20-有效的括号匹配" class="headerlink" title="20.有效的括号匹配"></a><span id="more"></span>20.有效的括号匹配</h3><p>提示：用栈来匹配，遇到( [ {就入栈，否则就出栈看是否和现在的匹配，此时如果匹配就继续，如果不匹配或者栈空(说明有多余的括号)就返回true，最后看栈是否为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; opstack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">           <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               opstack.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">               opstack.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">               opstack.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(opstack.<span class="built_in">empty</span>() || c != opstack.<span class="built_in">top</span>())&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               opstack.<span class="built_in">pop</span>();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> opstack.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="150-逆波兰式表达式求值"><a href="#150-逆波兰式表达式求值" class="headerlink" title="150.逆波兰式表达式求值"></a>150.逆波兰式表达式求值</h3><p>提示：遇到数字就压栈，遇到操作符就出栈两个数字，计算结果再放入栈中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span> &gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str == <span class="string">&quot;+&quot;</span> || str == <span class="string">&quot;-&quot;</span>|| str == <span class="string">&quot;*&quot;</span>|| str == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> num2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(str == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num1+num2);</span><br><span class="line">                <span class="keyword">if</span>(str == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num1-num2);</span><br><span class="line">                <span class="keyword">if</span>(str == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num1*num2);</span><br><span class="line">                <span class="keyword">if</span>(str == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(num1/num2); </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(str));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h3><p>提示：采用单调队列</p>
<p>单调队列的push会删除所有前面小于进来元素的值的元素，因为这些值已经不可能成为这个窗口中的最大值了；单调队列的pop会与队列中第一个也是最大的元素比较，当相等时说明窗口要抛弃这个最大值了，最大值就由其后面的次大值担任；因为进来的大元素会删除前面的小元素，我们可以知道这个将要被抛弃的最大值一定会比其他元素进来的早(若果进来的晚那其他小元素应该被删除，说明其他小元素是后进来的)，所以pop抛弃的只可能是这个大元素或者因为这个大元素进来而已经被搞掉的小元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">My_queue</span>&#123;</span> <span class="comment">//单调队列有一个重要的性质：在队列中所有元素按照进来的顺序和大小排列,队列里放的都是有可能成为最大的元素的值(因为我们还不知道pop的是不是之前的最大值)</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>())&#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()&amp;&amp; value&gt;que.<span class="built_in">back</span>())&#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        My_queue window;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;k<span class="number">-1</span>)&#123; <span class="comment">//先把前k-1个放到windows里</span></span><br><span class="line">                window.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                window.<span class="built_in">push</span>(nums[i]);<span class="comment">//放入新加入的元素</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(window.<span class="built_in">front</span>()); <span class="comment">//返回最大的元素</span></span><br><span class="line">                window.<span class="built_in">pop</span>(nums[i-k+<span class="number">1</span>]);<span class="comment">//把之前的那个踢出去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h3><p>提示：找k个最大的用小顶堆，每次加入元素将最小的那个取出来剩下的就是较大的数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">mycomparision</span>&#123;</span></span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;lhs,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;rhs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second&gt;rhs.second;   <span class="comment">//谁小谁排前面，默认是大顶堆，现在就是小顶堆了</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            map[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;,mycomparision&gt; pri_que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>();it!=map.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="keyword">if</span>(pri_que.<span class="built_in">size</span>()&gt;k)&#123;</span><br><span class="line">                pri_que.<span class="built_in">pop</span>(); <span class="comment">//如果小顶堆的大小大于k，就把栈顶元素取出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            result[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode4.8</title>
    <url>/post/1bb8e013/</url>
    <content><![CDATA[<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a><span id="more"></span>回溯算法</h3><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h3><p>理解：用递归来代替循环，k次循环就是用k层的递归来代替，每进一次递归从选择列表中找到一个元素加到路径中，backtrack剩下的选择列表和路径，最后把刚才的选择从选择列表中撤销，可以把这当成一个模版使用</p>
<p>注意：这道题中的选择列表在不断缩小，从i+1开始</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> n , vector&lt;<span class="keyword">int</span>&gt;&amp; result,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(result);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;=n;i++)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtrack</span>(i+<span class="number">1</span>,n,result,k);</span><br><span class="line">            result.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">1</span>,n,result,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="77-组合问题剪枝"><a href="#77-组合问题剪枝" class="headerlink" title="77.组合问题剪枝"></a>77.组合问题剪枝</h3><p>可以剪枝的地方就在于递归中每一层的for循环所选择的起始位置。如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素的个数了，那么就没有必要搜索了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> n , vector&lt;<span class="keyword">int</span>&gt;&amp; result,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(result);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;=n-(k-result.<span class="built_in">size</span>())+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtrack</span>(i+<span class="number">1</span>,n,result,k);</span><br><span class="line">            result.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">1</span>,n,result,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> n , vector&lt;<span class="keyword">int</span>&gt;&amp; result,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(result);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;=n-(k-result.<span class="built_in">size</span>())+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtrack</span>(i+<span class="number">1</span>,n,result,k);</span><br><span class="line">            result.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">1</span>,n,result,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> n , vector&lt;<span class="keyword">int</span>&gt;&amp; result,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(result);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;=n-(k-result.<span class="built_in">size</span>())+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtrack</span>(i+<span class="number">1</span>,n,result,k);</span><br><span class="line">            result.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">1</span>,n,result,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="216组合总和"><a href="#216组合总和" class="headerlink" title="216组合总和"></a>216组合总和</h3><p>提示：当sum之和大于n时可以剪枝，直接返回上一层</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k ,<span class="keyword">int</span> n,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()== k)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = start;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="built_in">backtrack</span>(k,n,i+<span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><p>注意：我的方法太复杂了，完全可以用index和string来进行递归，不一定非用vector，但思路是一致的，每次递归在一个数字对应的字符串中进行循环，递归就把index+1寻找下个数字。一定要注意如何定义选择列表，这里每一个数字都代表一个选择列表，进入下一次递归就是传入下一个数字的index从而获得其对应的选择列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,vector&lt;string&gt;&gt; dic;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(vector&lt;string&gt;&amp; digitstr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == digitstr.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:dic[digitstr[k]])&#123;</span><br><span class="line">            path = path+c;</span><br><span class="line">            <span class="built_in">back_track</span>(digitstr,k+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">            dic[<span class="string">&quot;2&quot;</span>] = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">            dic[<span class="string">&quot;3&quot;</span>] = &#123;<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>&#125;;</span><br><span class="line">            dic[<span class="string">&quot;4&quot;</span>] = &#123;<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>&#125;;</span><br><span class="line">            dic[<span class="string">&quot;5&quot;</span>] = &#123;<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>&#125;;</span><br><span class="line">            dic[<span class="string">&quot;6&quot;</span>] = &#123;<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>&#125;;</span><br><span class="line">            dic[<span class="string">&quot;7&quot;</span>] = &#123;<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;s&quot;</span>&#125;;</span><br><span class="line">            dic[<span class="string">&quot;8&quot;</span>] = &#123;<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">            dic[<span class="string">&quot;9&quot;</span>] = &#123;<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> vector&lt;string&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;string&gt; digitstr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c:digits)&#123;</span><br><span class="line">                digitstr.<span class="built_in">push_back</span>(<span class="built_in">string</span>(<span class="number">1</span>,c));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">back_track</span>(digitstr,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="39-组合总数"><a href="#39-组合总数" class="headerlink" title="39.组合总数"></a>39.组合总数</h3><p>提示：组合问题需要有一个start指出下一层递归的选择列表从哪里开始，这道题可以自己重复自己，所以选择列表是i而不是i+1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> sum ,<span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span> (candidates[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(candidates,target,sum,i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode4.9</title>
    <url>/post/6cbfd085/</url>
    <content><![CDATA[<h3 id="40-组合总和"><a href="#40-组合总和" class="headerlink" title=" 40.  组合总和"></a><span id="more"></span> 40.  组合总和</h3><p>注意：一定要区分层间的重用和层内的重用，所谓回溯就是遍历一棵树的过程，本题中层间是不能重用的，一定要记住</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> sum,<span class="keyword">int</span> startInex,vector&lt;<span class="keyword">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startInex;i&lt;candidates.<span class="built_in">size</span>()&amp;&amp; sum+candidates[i]&lt;=target;i++)&#123;</span><br><span class="line">            <span class="comment">//used[i-1] == true;说明同一树枝candinates[i-1]使用过</span></span><br><span class="line">            <span class="comment">//used[i-1] == false;说明同一数层candinates[i-1]被使用过</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;candidates[i] == candidates[i<span class="number">-1</span>]&amp;&amp; used[i<span class="number">-1</span>]==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">back_track</span>(candidates,target,sum,i+<span class="number">1</span>,used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            sum -=candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt;<span class="built_in">used</span>(candidates.<span class="built_in">size</span>(),<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">back_track</span>(candidates,target,<span class="number">0</span>,<span class="number">0</span>,used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p>提示：依旧是一个回溯问题，关键在于能否找到一个选择列表，对于切割问题而言，选择列表就是从startIndex到i的子串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRecursive</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[s.<span class="built_in">size</span>()-i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; path; <span class="comment">//path 就是分割方案</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(string &amp;s,<span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(startIndex&gt;=s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = startIndex;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string str = s.<span class="built_in">substr</span>(startIndex,i-startIndex+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isRecursive</span>(str))&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">back_track</span>(s,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">back_track</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><p>提示：本题的关键还是字符串的划分，字符串的选择列表是 startIndex到i-startIndex+1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>&amp;&amp;str.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;<span class="string">&#x27;9&#x27;</span>||str[i]&lt;<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num*<span class="number">10</span>+(str[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">255</span>||num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(<span class="keyword">const</span> string &amp; s,<span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==<span class="number">4</span>&amp;&amp;startIndex == s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;queshi cunzai &quot;&lt;&lt;endl;</span></span><br><span class="line">            string ip;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str:path)&#123;</span><br><span class="line">                ip = ip+str+<span class="string">&quot;.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ip.<span class="built_in">pop_back</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(ip);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()&gt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(startIndex&gt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string str = s.<span class="built_in">substr</span>(startIndex,i-startIndex+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(str))&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">back_track</span>(s,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">12</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">back_track</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="78子集"><a href="#78子集" class="headerlink" title="78子集"></a>78子集</h3><p>提示：子集问题的关键在于这颗二叉树的每一个节点都要放到result中，我们用path记录每一次的结果并将结果放入result中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="built_in">backtrack</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums,<span class="number">0</span>);</span><br><span class="line">        result.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>在这里</title>
    <url>/post/4f46e11/</url>
    <content><![CDATA[<p>javascript是一门充满活力、简单易用的语言，又是一门具有许多复杂微妙技术的语言。即使是经验丰富的javascript开发者，如果没有认真学习的话，也无法真正理解它们，这就是javascript的矛盾之处。由于javascript不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。不满足于只是让代码正常工作，而是想要弄清楚为什么，勇于挑战这条崎岖颠簸的少有人走的路，拥抱整个javascript</p>
<span id="more"></span>后面的内容在首页不显示，只显示到<!--more-->这里

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>重载运算与类型转换</title>
    <url>/post/undefined/</url>
    <content><![CDATA[<h3 id="14-1基本概念"><a href="#14-1基本概念" class="headerlink" title="14.1基本概念"></a><span id="more"></span>14.1基本概念</h3><ol>
<li><p>当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的参数数量比运算对象的数量少一个。</p>
</li>
<li><p>当重载的运算符不是成员函数时，首先他不能定义两个内置类型，其参数和运算对象一样多</p>
</li>
<li><p>复习：逗号表达式先对左侧求值，然后把结果扔掉，返回右侧表达式的值，若右侧表达式是左值，最终的求值结果也是左值</p>
</li>
<li><p>我们可以将运算符作用于类型正确的实参，从而间接方式“调用”重载的运算符函数；也可以像调用普通函数一样直接调用运算符函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">data1 + data2;</span><br><span class="line"><span class="keyword">operator</span>+(data1,data2); <span class="comment">//这两种方法等价</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为&amp;&amp; ||的短路求值属性，和逗号运算符的求值顺序无法保留下来，因此我们不建议重载他们</p>
</li>
<li><p>不重载逗号运算符和取址运算符的另外一个原因是，C++已经规定了他们作用于类类型对象时的含义；因为有了内置含义，所以一般来说他们不应该被重载</p>
</li>
<li><p>应该使用与内置类型一致的含义</p>
</li>
<li><p>逻辑运算和关系运算应该返回bool，算数运算符应该返回一个类类型的值，赋值运算符和复合运算符应该返回左侧运算对象的引用</p>
</li>
<li><p>只有当操作的含义对于用户来说清晰明了时才使用运算符</p>
</li>
<li><p>如果类由算数运算符或者位运算符，最好也提供对应的复合赋值运算，比如有+最好同时定义+=</p>
</li>
<li><p>运算符可以作为类的成员函数，也可以声明为一个普通的非成员函数</p>
<ul>
<li>赋值(= ),下标([ ]),调用(( ))和成员访问箭头(-&gt;)必须是成员</li>
<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同</li>
<li>改变对象状态的运算符或者给定类型密切相关的运算符，如递增，递减和解引用运算符，通常应该是成员</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算数,相等性，关系和位运算符等，因此他们通常应该是普通的非成员函数</li>
</ul>
</li>
<li><p>如果我们提供含有类对象的混合类型表达式，则运算符必须定义为非成员函数</p>
</li>
<li><p>对一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数</p>
</li>
</ol>
<h3 id="14-2输入和输出运算符"><a href="#14-2输入和输出运算符" class="headerlink" title="14.2输入和输出运算符"></a>14.2输入和输出运算符</h3><ol>
<li>通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符</li>
<li>如果我们希望为类自定义IO运算符，则<strong>必须将其定义为非成员函数</strong>，且应该声明为友元</li>
<li>输入运算符必须处理输入可能失败的情况，而输出运算符不需要</li>
<li>当读取操作发生错误时，输入运算符应该负责从错误中恢复</li>
<li>我们可以用io库的那些failbit，eofbit，和badbit来获取流的状态（P279）</li>
<li>eof( )表示流到末尾，bad()表示流损坏，二者都会导致fail为true</li>
</ol>
<h3 id="14-3-算数和关系运算符"><a href="#14-3-算数和关系运算符" class="headerlink" title="14.3 算数和关系运算符"></a>14.3 算数和关系运算符</h3><ol>
<li><p>如果类定义了算数运算符，则他一般也会定义一个对应的复合赋值运算符</p>
</li>
<li><p>如果同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值运算符来实现算数运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sale_data <span class="keyword">operator</span>+(<span class="keyword">const</span> Sale_data &amp;lhs,<span class="keyword">const</span> Sale_data &amp;rhs)&#123;</span><br><span class="line">    Sales_data sum = lhs;<span class="comment">//</span></span><br><span class="line">    sum += rhs; <span class="comment">//调用复合赋值运算符</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个类定义了operator==，则这个类也应该定义operator!=;我们只让其中一个工作，另外一个则调用真正工作的运算符 <code>return !(rhs==lhs);</code>这种就可以</p>
</li>
</ol>
<h3 id="14-4赋值运算符"><a href="#14-4赋值运算符" class="headerlink" title="14.4赋值运算符"></a>14.4赋值运算符</h3><ol>
<li><p>除了拷贝赋值和移动赋值运算符外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	StrVec &amp;<span class="keyword">operator</span>=(initializer_list&lt;string&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无论形参类型是什么，<strong>赋值运算符都必须定义为成员函数</strong></p>
</li>
<li><p>复合赋值运算符不非是类的成员，但我们倾向与把包括复合赋值在内的所有赋值运算都定义在类的内部，返回其左侧对象的引用</p>
</li>
<li><p>注意赋值运算符完成构造和析构两个过程</p>
</li>
</ol>
<h3 id="14-5下标运算符"><a href="#14-5下标运算符" class="headerlink" title="14.5下标运算符"></a>14.5下标运算符</h3><ol>
<li>如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用<code>string &amp; operator[](size_t n);</code>和<code>const string&amp; operator[](size_t n) const</code></li>
</ol>
<h3 id="14-6递增和递减运算符"><a href="#14-6递增和递减运算符" class="headerlink" title="14.6递增和递减运算符"></a>14.6递增和递减运算符</h3><ol>
<li><p>因为他们改变的是类的成员，所以建议将其设定为成员函数</p>
</li>
<li><p>应该同时定义前置版本和后置版本</p>
</li>
<li><p>后置的版本接受一个额外的（不被使用）的int类型的形参，编译器会默认给它实参0；我们不会使用这个形参，其唯一的作用就是区分前置版本和后置版本的函数，而不是要真的实现后置版本时参与计算</p>
</li>
<li><p>后置运算符返回对象的原值，返回的是值而非引用（需要先保存原来的值，再在最后返回），再将原对象进行++操作，调用前置版本的++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;       <span class="comment">//记录当前的值</span></span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回之前记录的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li>如果显示调用后置版本的++,我们必须给它一个int以区分前置版本的 ++</li>
</ol>
<h3 id="14-7成员访问运算符"><a href="#14-7成员访问运算符" class="headerlink" title="14.7成员访问运算符"></a>14.7成员访问运算符</h3><ol>
<li><p>箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址</p>
</li>
<li><p>可以将箭头运算符理解为如下 形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">point.<span class="keyword">operator</span>-&gt;()-&gt;mem;<span class="comment">//注意这可能是一个套娃，因为point.operator-&gt;()返回的也可能是一个</span></span><br><span class="line"><span class="comment">//类(指针类）的对象，碰到了-&gt;又开始调用重载的operator-&gt;，知道point成为一个指针，真的指向了mem成员</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重载-&gt;可以认为是改变了从哪个对象中获取成员</p>
</li>
<li><p>我自己感觉只有行为类似指针的类才需要重载-&gt;，而一般的数值类不会重载-&gt;</p>
</li>
<li><p>-&gt;最终返回的是一个地址，之后他会继续使用-&gt;,直到用内置版本的-&gt;</p>
</li>
</ol>
<h3 id="14-8函数调用运算符"><a href="#14-8函数调用运算符" class="headerlink" title="14.8函数调用运算符"></a>14.8函数调用运算符</h3><ol>
<li><p>如果类定义了调用运算符，则该类对象称作函数对象 。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样）</p>
</li>
<li><p>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别</p>
</li>
<li><p>函数对象类通常含有一些数据成员，被用于定制调用运算符中的操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream&amp; o = cout,<span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>):<span class="built_in">os</span>(o),<span class="built_in">sep</span>(c)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span> </span>&#123;os&lt;&lt;s&lt;&lt;sep&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;      <span class="comment">//将输入写入目的流</span></span><br><span class="line">    <span class="keyword">char</span> sep;         <span class="comment">//用于将不同输出隔开的字符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数对象常常作为泛型算法的实参，例如可以用for_each算法</p>
</li>
<li><p>A(a)会生成一个临时对象</p>
</li>
<li><p>lambda是函数对象，和写一个类再生成一个临时的函数对象的写法没有区别</p>
</li>
<li><p>lambda表达式产生的类不含默认构造函数,赋值运算符及默认析构；他是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员而定</p>
</li>
<li><p>标准库定义了一组表示算数运算符，关系运算符和逻辑运算符的类，每个类分别定义一个执行命名操作的调用运算符；这些类都被定义为模板的形式，可以为其指定具体的应用类型，这里的类型即为调用运算符的形参类型。例如,plus<string>加法运算作用于string对象；</string></p>
</li>
<li><p>标准库函数对象在functional头文件中</p>
</li>
<li><p>可以用函数对象代替默认运算符</p>
</li>
<li><p>指针类型不能进行关系比较，会产生未定义的行为，但我们能用标准库函数对象比较大小</p>
</li>
<li><p>关联容器使用less<key_value>对元素进行排序，因此我们可以定义一个指针的set，或者在map中使用指针作为关键值而无需声明less</key_value></p>
</li>
<li><p>复习：bind是一种函数适配器，它接受一个可调用对象，生成一个新的可调用对象，生成一个新的可调用对象来”适应“原对象的参数列表</p>
</li>
<li><p>复习：如果一个lambda包含return以外的任何语句，则编译器假定它返回一个void，此时若想说明返回的类型不是void，就要加上位置返回类型的说明。（如果只有一个return，则它会根据return的类型，自动判断应该返回的类型</p>
</li>
<li><p>for_each是只读的，除非传入引用并且改变引用的对象的值，其默认返回void</p>
</li>
<li><p>将标准库函数和bind联合使用形成谓词从而用在泛型算法中是一种常见的用法</p>
</li>
<li><p>c++中可调用对象有：函数，函数指针，lambda表达式，bind创建的对象，以及重载了函数调用运算符的类（函数对象）</p>
</li>
<li><p>lambda有自己唯一的未命名类类型；函数及函数指针的类型由返回值类型和实参类型决定</p>
</li>
<li><p>两个不同类型的可调用对象能共享同一张调用形式。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，如int (int  int )</p>
</li>
<li><p>向一个map中加入元素的方式最简单的有两种一个是<code>map.insert(&#123;a,b&#125;)</code>一个是<code>map.insert(make_pair(a,b))</code>,只要记住加入的是一个pair就行，第一种列表会自动转化为pair，等价于<code>pair&lt;A,B&gt;(a,b)</code></p>
</li>
<li><p>fuction&lt;调用形式&gt; f = 可调用对象，就可以将f变为可调用对象的副本，且统一可调用对象的类型为调用形式的类型</p>
</li>
<li><p>尽管可调用对象的类型各不相同，我们仍然能够把左右这些类型都存储在同一个<code>function&lt;int (int,int)&gt;</code>类型中，并且进行调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;string,function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;+&quot;</span>,add&#125;,         <span class="comment">//普通函数指针</span></span><br><span class="line">    &#123;<span class="string">&quot;-&quot;</span>,minus&lt;<span class="keyword">int</span>&gt;()&#125;,<span class="comment">//标准库函数对象；</span></span><br><span class="line">    &#123;<span class="string">&quot;/&quot;</span>,<span class="built_in">divide</span>()&#125;,    <span class="comment">//函数对象；</span></span><br><span class="line">    &#123;<span class="string">&quot;*&quot;</span>,[](<span class="keyword">int</span> i,<span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i*j;&#125;&#125;, <span class="comment">//未命名的lambda</span></span><br><span class="line">    &#123;<span class="string">&quot;%&quot;</span>,mod&#125;;        <span class="comment">//命名了的lambda对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只能说bind和标准库对象是绝配</p>
</li>
<li><p>复习：string的find函数会返回一个size_type类型的值表示下标，如果没找到就返回std::string::npos,npos是size_type可能取得的最大值</p>
</li>
<li><p>复习：能用stod转换的string必须是以+-012…9开头的string，因此一般我们用s.find_first_of获取第一个可以作为开头位置的pos，再用s.substr(pos)获得可以进行转换的子串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">char</span>,function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; functions&#123;&#123;<span class="string">&#x27;+&#x27;</span>,plus&lt;<span class="keyword">int</span>&gt;()&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,minus&lt;<span class="keyword">int</span>&gt;()&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,multiplies&lt;<span class="keyword">int</span>&gt;()&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,divides&lt;<span class="keyword">int</span>&gt;()&#125;&#125;;<span class="comment">//遇见不同的符号就会调用不同的函数</span></span><br><span class="line">   string expression;</span><br><span class="line">   <span class="keyword">while</span>(cin&gt;&gt;expression)&#123;</span><br><span class="line">       <span class="keyword">auto</span> pos = expression.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-*/&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> num1 = <span class="built_in">stoi</span>(expression.<span class="built_in">substr</span>(<span class="number">0</span>,pos));</span><br><span class="line">       <span class="keyword">int</span> num2 = <span class="built_in">stoi</span>(expression.<span class="built_in">substr</span>(pos+<span class="number">1</span>));</span><br><span class="line">       <span class="keyword">char</span> op = expression[pos];</span><br><span class="line">       <span class="keyword">auto</span> result = functions[op](num1,num2);</span><br><span class="line">       cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="14-9重载类型转换与运算符"><a href="#14-9重载类型转换与运算符" class="headerlink" title="14.9重载类型转换与运算符"></a>14.9重载类型转换与运算符</h3><ol>
<li>转换构造函数(只接受一个参数的非explicit构造函数)和类型转换运算符共同定义了类类型转换，这样的转换有时也被称作用户定义的类型转换（user-defined conversions）</li>
<li>一个类型转换函数必须是类的成员函数；他不能声明返回类型，形参列表也必须为空。因为它一般不改变待转换对象的内容，所以类型转换运算符一般被定义成const成员</li>
<li>无论类类型发生隐式转换前还是后，都可以进行内置类型转换，也就是说可以从 double转为int在转为类A，也可以从A转为int再转为double</li>
<li>因为转换是隐式进行的，所以没有参数；因为要转换成的类型就是返回的类型，所以不需要声明返回类型。</li>
<li>避免过度使用类型转换函数，可以设计普通的成员函数来代替</li>
<li>一般情况下，不会定义类型转换，但是定义向bool类型转换还是比较普遍的现象</li>
<li>为了防止莫名的类型转换运算符，C++11引入了显式的类型转换运算符，就是operator前加上explicit</li>
<li>当表达式被用作条件，编译器会将显式的类型转换自动的应用于它</li>
<li>向bool的类型转换通常在条件部分，这是explict也能进行隐式的转换，所以operator bool一般可以定义为explicit的</li>
<li>两个类不要定义相同的类型转换（A可以通过A的构造函数转换B为A，也可以通过B的类型转换运算符将B转换为A);也不要在类中定义两个及两个以上转换源或者转换目标是算数类型的转换</li>
<li>当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配是到底是哪个</li>
<li>总而言之，除了显式地向bool类型的转换之外，我们应该避免定义类型转换函数并尽可能的限制非显式构造函数</li>
<li>在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性 </li>
<li>简单来说，只要一个数能同时转化为两个函数都能调用的情况，就说明有二义性，只有被相同的函数调用时，转化的优先级才有意义；就是不能又可以转换为A又能转换为B，这样就会不知道调用哪个函数，从而产生二义性；如果它能确定只转换为一个用户定义的类型转换中的类型，那么优先级才有用</li>
<li>如果我们对同一个类提供了转换目标是算数类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题（类型转换为算数类型进行内置运算或者是直接调用重载运算符）</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>模版与泛型编程</title>
    <url>/post/94994349/</url>
    <content><![CDATA[<p>Just do it !!!<span id="more"></span></p>
<h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><ol>
<li>当我们编写一个泛型程序时，独立于任何特定类型编写代码。当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行</li>
<li>标准库为容器提供了单一的，泛型的定义，如vector。我们可以用泛型定义很多类型的vector，他们的差异就在于包含的元素类型不同，</li>
<li>我们定义自己的模板类型，根据提供给模板的具体类型，生成用法相似的类</li>
<li>模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</li>
</ol>
<h3 id="16-1定义模板"><a href="#16-1定义模板" class="headerlink" title="16.1定义模板"></a>16.1定义模板</h3><ol>
<li>函数模板，定义一个函数，以相似的方法处理不同类型的数据。一个函数模板就是一个公式，用来生成针对特定类型的函数版本。</li>
<li>模板参数列表不能为空，模板参数一般是类型，也可能是值</li>
<li>当我们调用一个函数模板时，编译器通常用函数实参来为我们推断模板实参；这个过程叫实例化，编译器生成的版本通常被称为模板的实例</li>
<li>一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明</li>
<li>类型参数前必须使用关键字class 或typename，推荐使用typename</li>
<li>一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename指定非类型参数。</li>
<li>当一个模板被实例化，非类型参数被一个用户提供的或编译器推断出的所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板</li>
<li>在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，如指定数组大小</li>
<li>非类型模板参数必须是常量表达式</li>
<li>inline放在 template后面</li>
<li>模板中的函数参数是const的引用</li>
<li>函数体中的条件判断仅仅使用&lt;比较运算符</li>
<li>模板程序应该尽量减少对实参类型的要求</li>
<li>通常我们调用一个函数时，编译器只需要掌握函数的声明；类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此我们将类定义和函数声明放在头文件中，普通函数和类的成员函数的定义放在源文件中</li>
<li>编译器在模板实例化的过程中，需要掌握函数模板或类模板成员函数的定义。函数模板和类模板成员函数的定义通常放在头文件中</li>
<li>我们必须显式的为类模板提供模板参数，写到&lt;&gt;中，定义一个模板类时，也不过是把类型当参数传入类中而已</li>
<li>显式模板实参为我们实例化出特定的类，他完整了这个类</li>
<li>一个类模板的每个实例都形成一个独立的类。类型vector<string>与任何其他blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限</string></li>
<li>一个模板生成的类的名字中必须包含其模板实参。当我们定义一个成员函数时，模板实参与模板形参相同</li>
<li>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化</li>
<li>在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板参数</li>
<li>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span><span class="comment">//定义类模板</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> vector&lt;T&gt;::size_type size_type;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Blob</span>();</span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; );</span><br><span class="line">    <span class="comment">//Blob中的元素数目</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> data-&gt;<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> data-&gt;empty;&#125;</span><br><span class="line">    <span class="comment">//添加和删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T &amp; t)</span></span>&#123;data-&gt;<span class="built_in">push_back</span>(t);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp; t)</span></span>&#123;data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;vector&lt;T&gt;&gt; data;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i,<span class="keyword">const</span> string &amp;msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//相当于声明了一个函数模板</span></span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="keyword">const</span> string &amp;msg) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=data-&gt;<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span>[](size_type i) &#123;</span><br><span class="line">    <span class="built_in">check</span>(i,<span class="string">&quot;subscript out of range&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::<span class="built_in">pop_back</span>() &#123;</span><br><span class="line">    <span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;pop_back on empty Blob&quot;</span>);</span><br><span class="line">    data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>():<span class="built_in">data</span>(make_shared&lt;vector&lt;T&gt;&gt;())&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt;</span><br><span class="line">il) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlobPtr</span>():<span class="built_in">curr</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">BlobPtr</span>(Blob&lt;T&gt; &amp;a,<span class="keyword">size_t</span> sz=<span class="number">0</span>):<span class="built_in">wptr</span>(a.data),<span class="built_in">curr</span>(sz)&#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p =  <span class="built_in">check</span>(curr,<span class="string">&quot;deference past end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">    &#125;</span><br><span class="line">    BlobPtr&amp; <span class="keyword">operator</span>++();<span class="comment">//前置运算符</span></span><br><span class="line">    BlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">//后置运算符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;vector&lt;T&gt;&gt; <span class="built_in">check</span>(<span class="keyword">size_t</span>,string&amp;) <span class="keyword">const</span>;</span><br><span class="line">    weak_ptr&lt;vector&lt;T&gt;&gt; wptr;</span><br><span class="line">    <span class="keyword">size_t</span> curr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++ *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h4><ol>
<li>类和友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例</li>
<li>如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例</li>
</ol>
<h5 id="一对一友好关系"><a href="#一对一友好关系" class="headerlink" title="一对一友好关系"></a>一对一友好关系</h5><p>最常见的形式是建立对应实例及其友元间的友好关系</p>
<p>为了引用模板的一个特定实例，我们必须首先声明模板自身。一个模板声明包括模板参数列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> &gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span><span class="comment">//因为下面的operator==参数中要用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt;&amp;,<span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span><span class="comment">//定义类模板</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//每个Blob实例将访问权限授予（相同类型实例化）的BlobPtr和相等运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;</span>T&gt;; <span class="comment">//友元的声明用Blob模板的形参做自己的模板实参。友好关系被限定在用相同类型实例化</span></span><br><span class="line">    <span class="comment">//的Blob与BlobPtr相等运算符之间</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt;&amp;,<span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br></pre></td></tr></table></figure>

<h5 id="通用和特定的模板友好关系"><a href="#通用和特定的模板友好关系" class="headerlink" title="通用和特定的模板友好关系"></a>通用和特定的模板友好关系</h5><p>一个类也可以将另一个模板的所有实例都声明为自己的友元，或者限定特定的实例为友元</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> &gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span><span class="comment">//声明一个友元模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;;<span class="comment">//用类C实例化的Pal是C的一个友元，限定特殊的类为友元</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span><span class="comment">//Pal2的所有实例都是C的友元；这种情况无需前置声明</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">C2</span>&#123;</span> <span class="comment">//C2本身是一个类模板</span></span><br><span class="line">    <span class="comment">//C2的每个实例将相同实例化的Pal声明为友元；</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;;<span class="comment">//Pal的模板声明必须在作用域之内</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span><span class="comment">//Pal2的所用实例都是C2的每个实例的友元，不需要前置声明，为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span> <span class="comment">//Pal3是一个非模板类，它是C2的所用实例的友元</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>综上所述，简而言之，一个类可以所有的实例都是所有类模板实例的友元（多对多），也可以只有特定实例是所有类模板的友元（多对一），还可以特定实例是特定类的友元（一对一），当然也能是所有实例都是某个类的友元（一对多）</p>
<h5 id="令模板自己类型参数成为友元"><a href="#令模板自己类型参数成为友元" class="headerlink" title="令模板自己类型参数成为友元"></a>令模板自己类型参数成为友元</h5><p>就是将把模型自己的类型参数（通常是一个类),作为这个类模板的友元类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> Type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Type可以是内置类型</p>
<h5 id="模板类型别名"><a href="#模板类型别名" class="headerlink" title="模板类型别名"></a>模板类型别名</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line">twin&lt;string&gt; authors; <span class="comment">//authors是一个pair&lt;string,string&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个模板类型的别名是一族类的别名</p>
<h5 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h5><p>如果ctr 是static的，对于任意给定类型X，都有一个Foo<X>::ctr和一个Foo<X>::count。所有Foo(X)类型的对象共享相同的ctr对象和count函数。</X></X></p>
<p>每个类型都有独立的ctr，我们定义ctr时需要与成员函数类似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>静态成员函数同样在使用时才会实例化</p>
<h4 id="16-1-3模板参数"><a href="#16-1-3模板参数" class="headerlink" title="16.1.3模板参数"></a>16.1.3模板参数</h4><ol>
<li>模板参数的作用域在类模板和模板函数内</li>
<li>使用类的类型成员需要在前面加typename，因为T：：size_type不能分清楚size_type是静态成员还是类型成员，默认是静态成员，如果是类型成员就要在前面加上typename</li>
<li>与函数实参类似，模板参数也可以有默认实参，函数也可以有；与往常一样，模板参数的类型从他们对应的函数实参推断而来。</li>
<li>当它右侧的所有参数都有默认实参时，它才可以有默认实参</li>
<li>对于类模板来说，就算指定了所有默认实参，也要加一个空的&lt;&gt;</li>
<li><strong>在模板内不能重用模板参数名</strong></li>
</ol>
<h4 id="16-1-4成员模板"><a href="#16-1-4成员模板" class="headerlink" title="16.1.4成员模板"></a>16.1.4成员模板</h4><ol>
<li><p>一个类包含本身是模板类的成员函数。这种成员被成为成员模板。模板不能是虚函数</p>
</li>
<li><p>下面的例子将定义一个删除器（函数对象，重载调用运算符），它应该和unique_ptr的默认删除器的功能类似，可以处理各种类型数据的指针，而不是那种我们需要传入一个删除器的unique_ptr,我们可以把他的调用运算符声明为模板函数，这样就能根据传入的参数推断类型，从而删除各种类型的指针了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DebugDelete</span>(std::ostream &amp;s = cerr)::<span class="built_in">os</span>(s)&#123; &#125;</span><br><span class="line">    <span class="comment">//与任何函数模板相同，T的类型由编译器推断</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        &#123;os&lt;&lt;<span class="string">&quot;deleting unique_ptr&quot;</span>&lt;&lt;std::endl;<span class="keyword">delete</span> p;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类模板也可以有成员模板，在此情况下，类和成员各自有自己的，独立的模板参数</p>
</li>
<li><p>在类外定义成员模板时，模板类的参数列表在前，后跟成员自己的模板列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; Blob&lt;T&gt;::<span class="built_in">Blob</span>(It b,It e):<span class="built_in">data</span>(make_shared&lt;vector&lt;T&gt;&gt;(b,e))&#123; &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="16-1-5控制实例化"><a href="#16-1-5控制实例化" class="headerlink" title="16.1.5控制实例化"></a>16.1.5控制实例化</h4><ol>
<li><p>因为当模板被使用时才会进行实例化，这一特性意味着：当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件都会有一个该模板的实例；实例化相同的模板的额外开销可能非常严重，我们可以通过显示实例化避免这种开销</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;<span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">//实例化定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于一个给定的实例化版本，可能有多个extern声明，但定义必须只能有一个</p>
</li>
<li><p>我们必须在另外一个模板中显式的给出一个模板的实例化如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> in <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt; ;<span class="comment">//实例化定义，只能在一个文件中有一次</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正常的默认实例化时，就在本文件，用这个模板的文件内进行实例化（编译成源代码）</p>
</li>
<li><p>而使用用显式实例化时，在链接阶段才会调用了实例化的类或者函数</p>
</li>
<li><p>因为显式实例化不知道哪个成员会用到，所以显式实例化会实例化一个类所有的成员</p>
</li>
<li><p>在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数，就是说用某个类型实例化一个模板时，能够调用这个模板所有的函数</p>
</li>
<li><p>通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，shared_ptr使用户重载删除器更为方便。<strong>shared_ptr的删除器必须保存为一个指针或者行为类似于指针的类</strong>，因为如果不存为指针的话不能知道它的具体类型，不能保存为一个对象成员,在调用时才能使用，我们还可以定义不同的删除器；而unqiue_ptr则可以在编译时将删除器的类型保存下来，成为这个类的一部分，在定义时就确定了删除器</p>
</li>
<li><p>总而言之：shared_ptr在运行时绑定删除器，通过将删除器的值赋予一个成员变量（指针类型）调用删除器指向的函数，unique_ptr在定义时确定删除器类型，避免了间接调用删除器的运行时开销</p>
</li>
<li><p>总结：删除器的类型 ：</p>
<ol>
<li><p>重载了( )的函数对象（其对应的类）</p>
</li>
<li><p>函数名（最为函数的指针）</p>
</li>
<li><p>lambda表达式（其实属于函数对象)</p>
</li>
</ol>
</li>
</ol>
<h3 id="16-2模板实参推断"><a href="#16-2模板实参推断" class="headerlink" title="16.2模板实参推断"></a>16.2模板实参推断</h3><ol>
<li><p>调用中应用于函数模板的包括如下两项：可以将一个非const对象的引用传递给一个const引用形参，</p>
<p>数组或函数指针转换，数组实参可以转换为指向其首元素的指针。一个函数实参可以转换为一个该函数类型的指针</p>
</li>
<li><p>复习：如果形参是一个引用，则数组不会转换为指针（数组不能被拷贝而已，但是引用是可以的)，且数组的大小也是数组类型的一部分，所以在模板中const T&amp; 如果传入数组int a[10],则T的类型应该是int[10]</p>
</li>
<li><p>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换</p>
</li>
<li><p>使用相同模板参数类型的函数形参推断出来的模板参数类型必须是一致的</p>
</li>
<li><p>如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数</p>
</li>
<li><p>只有const &amp; T ，const T*这种能进行向const的类型转换，普通的T不行（类型转换的const要本来就有而不能用T包含）</p>
</li>
<li><p>没有实参来推断模板类型的参数类型时，我们要定义显式模板实参</p>
</li>
<li><p>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换</p>
</li>
<li><p>由于尾置返回类型出现在形参列表之后，它可以使用函数的参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg,It end) -&gt;decltype(*beg)&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这种方式就不用显式的声明模板的返回类型参数</p>
</li>
<li><p>为了获得元素类型，我们可以使用标准库的类型转换模板，其定义在头文件type_traits中，书中606页定义了一些类型转换模板</p>
</li>
<li><p>remove_reference&lt;string &amp;&gt;::type是string类型，通过remove_reference模板可以得到对应引用模板类型参数的非引用模板</p>
</li>
<li><p>组合使用remove_reference,位置返回和decltype，我们就可以在函数中返回元素值的拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg ,It end)-&gt;</span><br><span class="line">	<span class="keyword">typename</span> remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">return</span> *beg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习16.41</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="function"><span class="keyword">auto</span> <span class="title">sum1</span><span class="params">(T a, T b)</span></span></span><br><span class="line">    -&gt; typename make_unsigned&lt;decltype(a)&gt;::type</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int16_t</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int16_t</span> b= <span class="number">2e15</span><span class="number">-1</span>; <span class="comment">//int的最大值，加1则变成最小值</span></span><br><span class="line">   <span class="keyword">auto</span> sumresult = <span class="built_in">sum1</span>(a,b);</span><br><span class="line">   cout&lt;&lt;sumresult&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">auto</span> sumresult2 = plus&lt;<span class="keyword">int16_t</span>&gt;()(a,b);</span><br><span class="line">   cout&lt;&lt;sumresult2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参</p>
</li>
<li><p><strong>void func (int(*)(int,int));</strong>可以声明一个函数指针fuc的类型，可以理解为后面的函数指针变成了函数类型</p>
</li>
<li><p>当参数是一个函数模板实例的地址时，程序上下文必须满足：对于每个模板参数，能唯一确定其类型或值</p>
</li>
<li><p><strong>从左值引用函数参数推断类型时，T&amp;只能传入一个左值</strong>，传入一个右值将不会进行推断；左值和右值的规则屏蔽了const int&amp;能传入字面值的规则</p>
</li>
<li><p><strong>类型参数推断区分底层const</strong></p>
</li>
<li><p>通过类型别名或通过模板类型参数间接定义引用的引用是可以的</p>
</li>
<li><p>折叠规则 X&amp;  &amp;，X&amp; &amp;&amp; ，和 X&amp;&amp; &amp;都折叠成X&amp;（左值引用）,只有X&amp;&amp; &amp;&amp;会被折叠为X&amp;&amp;（右值引用）</p>
</li>
<li><p>引用可以产生折叠，这样就能用引用的引用了，可以把左值传递给T&amp;&amp;,这时T被推断为T&amp;，通过折叠规则将左值传入</p>
</li>
<li><p>如果一个函数参数是指向模板参数类型的右值引用（如，T&amp;&amp;），则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&amp;）（通过折叠规则)</p>
</li>
<li><p>可以先这么认为：左值是可以作用取址运算符&amp;的持久变量，右值则是不能作用取址运算符&amp;的临时变量，和是否是const的无关</p>
</li>
<li><p><strong><em>只有当T&amp;和T&amp;&amp;时需要考虑左值和右值，因为&amp;只能绑定到左值，而&amp;&amp;能绑定到右值上也能绑到左值上，所以需要考虑实参的类型</em></strong></p>
</li>
<li><p>标准库是这么定义move的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type &amp;&amp; <span class="title">move</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;typname remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在语言层面上，我们用move将一个左值引用变成一个右值引用绑定到右值引用上，当我们使用过这个右值后，移后源不能再继续使用原来的值了；编译器不会在乎右值引用还是左值引用，需要我们自己保证不再使用移后源的值了（就像这个值被move走了一样，我们还可以对移后源进行赋值和删除操作，这和左值引用还是右值引用无关），简而言之，无论是左值引用还是右值引用都无关紧要，都是引用原对象，至于引用完之后怎么对待移后源，这是程序员需要保证的工作，编译器不会对此做出强制性的要求，所以所谓move，只能改变参数的类型，让我们的调用匹配（比如移动构造函数和移动赋值运算符，还有模板函数）</p>
</li>
<li><p>默认类型为T，这种传递默认会丢掉顶层const和引用，而是仅仅通过拷贝传参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">func</span>(T t1,T t2)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//传给t1的是const int &amp; ,也只会推断出t1的类型是int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。因为引用是底层const，所以const性质还会保留，T&amp;&amp;,能被推断出是const int &amp;，当传入的是常量左值引用时</p>
</li>
<li><p><strong>右值引用只能绑定到右值，右值引用的表达式还是左值</strong></p>
</li>
<li><p>重要的话重复三遍：</p>
<p>变量是左值。</p>
<p>变量是左值。</p>
<p>变量是左值。</p>
<p>rr1 在任何时候都是个左值，这与它的类型无关。std::move(rr1) 不是变量，所以它可以是左值还是右值就取决于它的类型</p>
</li>
<li><p>具名的右值引用是左值 不具名的右值引用是右值</p>
</li>
<li><p>总而言之，一个量是左值还是右值，和它是否是右值引用无关，只和它有没有名字有关（可以用&amp;）</p>
</li>
<li><p>用forward可以将一个本身为右值引用的左值变为一个右值引用的右值（失去变量的身份）</p>
</li>
<li><p>forward能保持左值引用和右值引用的类型，但是可以改变右值引用本身是左值的性质</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F,<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f,T1 &amp;&amp; t1,T2 &amp;&amp; t2)</span></span>&#123; <span class="comment">//t1,t2是左值引用右值引用都行</span></span><br><span class="line">	<span class="built_in">f</span>(std::forward&lt;T1&gt;(t2),std::forward&lt;T2&gt;(t2))<span class="comment">//f函数中，i1和i2是左值引用右值引用都行，这就是转发，通过forward保留左值还是右值，让左值引用成为左值，右值引用变为右值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">f</span>(<span class="keyword">int</span> &amp;&amp; i1 ,<span class="keyword">int</span>&amp; i2)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="16-3重载与模板"><a href="#16-3重载与模板" class="headerlink" title="16.3重载与模板"></a>16.3重载与模板</h3><ol>
<li>当有多个重载模板对一个调用提供更好的匹配时，应选择最特例化的版本；例如const T&amp; 比T*更加通用，所以当传入指针类型时我们选择更加特例化的T *版本</li>
<li>非模板函数比一个函数模板更好</li>
<li>在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本</li>
<li>不用类型转换(非const引用转换为const引用这种)&gt;需要类型转换；特例化版本&gt;非特例化版本（选择那个不是最通用的版本）；非模板精确匹配&gt;模板精确匹配；模板精确匹配&gt;非模板非精确匹配</li>
</ol>
<h3 id="16-4-可变参数模板"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板</h3><ol>
<li><p>参数包包括模板参数包，表示零个或多个参数模板；函数参数包，表示零个或多个函数参数。</p>
</li>
<li><p>用省略号指出一个模板参数或函数参数表示一个包。</p>
</li>
<li><p>我们可以用sizeof…(Args)获取包中元素的个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...Args&gt; <span class="comment">//Args是模板参数包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t,<span class="keyword">const</span> Args&amp; ...reset)</span><span class="comment">//reset是函数参数包</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可变参数函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身；为了终止递归，我们一般还需要定义一个非可变参数的递归出口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os,<span class="keyword">const</span> T&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;t;<span class="comment">//包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp;t,<span class="keyword">const</span> Args&amp;... reset)</span></span>&#123;</span><br><span class="line">    os&lt;&lt;t&lt;&lt;<span class="string">&quot;,&quot;</span>;<span class="comment">//打印第一个实参</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os,reset...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于参数包，我们需要用一种模式对其进行扩展，例如const Arg&amp; …就是一种模式的扩展；retset…</p>
<p>也是一种模式的扩展</p>
</li>
<li><p>扩展中的模式会独立地应用于包中的每个元素，fuc(args)…，先对args进行一种模式再扩展</p>
</li>
<li><p>组合可变参数模板与forward机制可以将实参不变的传给其他函数</p>
</li>
<li><p>建议：转发和可变参数模板就写成固定格式就行</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typname...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Args&amp;&amp;...args)</span><span class="comment">//这么写就可以运用折叠&amp;的规则接收左值和右值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(std::forward&lt;Args&gt;(args)...)</span><span class="comment">//这样就可以保持左值和右值不变，直接传递过来</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用转发和可变参数模板可以模拟一个类模板，处理所有传入的参数</p>
</li>
</ol>
<h3 id="16-5模板特例化"><a href="#16-5模板特例化" class="headerlink" title="16.5模板特例化"></a>16.5模板特例化</h3><ol>
<li>一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型</li>
<li><strong>特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配</strong></li>
<li>特例化版本能匹配到，原来的版本就能匹配到，但是一般特例化版本都会和原来的版本不同，从而处理更特殊的输入类型，而不是都用一个通用版本的函数模板来处理所有类型</li>
<li>模板及其实实例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本</li>
<li><strong>特例化版本和重载的普通版本最大的区别就是匹配的方式不同</strong>,一般来讲，匹配实例化版本和匹配到其原版本的优先级是相同的，但匹配普通版本就需要遵循一般的匹配规则了</li>
<li>一个特例化的类模板能处理更加特例的情况，比如我们自己定义的类型，所以有时候需要用到类模板的特例化</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象程序设计</title>
    <url>/post/fdd04c25/</url>
    <content><![CDATA[<p>No one is coming<span id="more"></span></p>
<h3 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h3><ol>
<li>面向对象程序设计基于三个基本概念：数据抽象，继承和动态绑定</li>
<li>继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类，二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别</li>
<li>在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望他的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数</li>
<li>派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的</li>
<li>派生类列表中使用public关键字，可以把派生类对象完全当成基类的对象来使用</li>
<li>派生类必须在其内部所有重新定义的虚函数进行声明；派生类可以在这样的函数之前加上virtual,也可以不这么做；C++新标准允许派生类显示地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在函数的形参列表之后增加一个override关键字</li>
<li>在c++中，我们使用基类的引用或指针调用一个虚函数时将发生动态绑定</li>
</ol>
<h3 id="15-2定义基类和派生类"><a href="#15-2定义基类和派生类" class="headerlink" title="15.2定义基类和派生类"></a>15.2定义基类和派生类</h3><hr>
<ol>
<li><p>基类通常都应该定义为一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
</li>
<li><p>基类希望派生类进行覆盖的函数定义为虚函数，调用该函数根据对象进行动态的绑定</p>
</li>
<li><p>任何构造函数之外的非静态函数都可以是虚函数。如果基类一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数</p>
</li>
<li><p>关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义</p>
</li>
<li><p>派生类的成员函数不一定有权访问从基类继承而来的成员。派生类能访问公有成员，不能访问私有成员。protectd成员是基类的派生类有权访问该成员，同时禁止其他用户访问</p>
</li>
<li><p>派生类列表的形式是：一个冒号，后面紧跟以逗号分割的基类列表，每个基类前面可以有以下三种访问说明符：pulic,protected或者private</p>
</li>
<li><p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明（但不一定是重写）</p>
</li>
<li><p>如果派生是public的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将共有派生类型的对象绑定到基类的引用或者指针上。大多数类都只继承自一个类，这种形式的继承称作单继承</p>
</li>
<li><p>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本</p>
</li>
<li><p>复习：我们用&amp;和&amp;&amp;限制this是左值还是右值，放在函数形参列表之后（const之后）</p>
</li>
<li><p>我们可以在引用限定符后面添加一个关键字override表示其覆盖它继承的虚函数</p>
</li>
<li><p>在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在</p>
</li>
<li><p>编译器会隐式地执行派生类到基类的转换，对于基类的引用和指针都能绑定到派生类上，出现基类的地方派生类也都可以出现</p>
</li>
<li><p>派生类不能直接初始化从基类继承的成员，必须使用基类的构造函数初始化其基类部分（每个类控制自己的成员初始化过程）</p>
</li>
<li><p>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员</p>
</li>
<li><p>一个派生类对象一般有三个部分的数据：一是基类中的private，二是基类中的protected，三是自己的private；第一种只有它继承的基类的函数才能访问操作（构造函数也包括在内，所以要初始化这一部分的数据就需要用基类的构造函数，还必须是显示的调用），第二种和第三种它自己定义的函数也能访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>:</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="keyword">const</span> string&amp;,<span class="keyword">double</span>,<span class="keyword">size_t</span>,<span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span>)</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> min_qiy = <span class="number">0</span> ; <span class="comment">//使用折扣政策的最低购买量</span></span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>; <span class="comment">//小数表示折扣额</span></span><br><span class="line">&#125;;</span><br><span class="line">Bulk_quote::<span class="built_in">Bulk_quote</span>(<span class="keyword">const</span> string &amp; book, <span class="keyword">double</span> p, <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):<span class="built_in">Quote</span>(book,p),<span class="built_in">min_qiy</span>(qty),<span class="built_in">discount</span>(disc) &#123;</span><br><span class="line">&#125; <span class="comment">//初始化分为两部分，一部分是基类中的成员一部分是派生类自己的成员</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类可以访问基类的公有成员和受保护成员，只有基类的函数才能访问基类的私有成员</p>
</li>
<li><p>派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员的方式和使用基类成员的方式没有什么不同</p>
</li>
<li><p><strong>关键概念：遵循基类的接口</strong>:每个类负责定义各自的接口。派生类对象不能直接初始化基类的成员，而是调用基类的构造函数来初始化它从基类中继承而来的成员</p>
</li>
<li><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的的唯一定义。不论从基类中派生出多少派生类，对于每个静态成员都存在唯一的实例；</p>
</li>
<li><p>静态成员遵循通用的访问规则，如果某静态成员是可访问的，我能通过基类使用它也可以通过派生类使用它</p>
</li>
<li><p>派生类的声明包括类名但是不包括它的派生列表</p>
</li>
<li><p>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明，因此一个类不能派生它本身</p>
</li>
<li><p>最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象</p>
</li>
<li><p>我们在类名后加上一个final，表示这个类不能被继承</p>
</li>
<li><p>理解基类和派生类之间的类型转换是理解面向对象编程的关键所在</p>
</li>
<li><p>当使用基类的引用或指针时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的,也可能是基类的子类</p>
</li>
<li><p><strong>指针和引用表达式有可能动态类型和静态类型不一样，因为虽然我们将指针和引用绑定到了一个基类上，但是实际调用时可能调用的是子类的对象（引用的是派生类的对象）。但是，不是说子类对象就能转换为基类对象，只有指针和引用这两个表达式能进行转换</strong></p>
</li>
<li><p>简而言之指针可能从A*类型变为A2 *类型，引用可能从A&amp; 变为A2&amp;,其中A2是A的派生类，A是A2的基类</p>
</li>
<li><p>一个基类的对象既可以以独立的形式存在，也可以以派生类对象的一部分存在，基类支持的，派生类都支持，所以派生类可以向基类转变，反之则不行</p>
</li>
<li><p>总而言之*<em>不存在基类向派生类的转换，在对象之间也不存在类型转换 *</em></p>
</li>
<li><p>当我们用一个派生类对象为一个基类对象初始化或赋值时（因为初始化和赋值接受的参数是const&amp;类型，所以可以将派生类对象绑定到基类引用上)只有该派生对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将会被<strong>切掉</strong> （忽略掉）</p>
</li>
<li><p>书上有总结，看536页吧</p>
</li>
</ol>
<h3 id="15-3虚函数"><a href="#15-3虚函数" class="headerlink" title="15.3虚函数"></a>15.3虚函数</h3><hr>
<ol>
<li>我们必须为每个虚函数都提供定义，而不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数</li>
<li>引用或指针的静态类型和动态类型不同这一事实正是C++语言支持多态性的根本所在</li>
<li>对非虚函数调用在编译时绑定。类似的，通过对象进行的函数（虚函数和非虚函数）调用也在编译时绑定</li>
<li>当且仅当通过指针和引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同</li>
<li>一旦某一个函数被声明成虚函数，则在所有的派生类中它都是虚函数（加不加virtual都行）</li>
<li>基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参和返回值必须与派生类中的形参严格匹配</li>
<li>如果我们在派生类中定义了和虚函数形参不同的函数，编译器会认为这是一个不同的函数，为了容易发现这个错误，我们可以用override关键字说明是派生类中的虚函数,此时如果我们没有覆盖已经存在的虚函数，编译器会报错</li>
<li>我们在const后面加上final，则之后任何尝试覆盖该函数的操作都将发生错误 ；在const，&amp;，&amp;&amp;，-&gt;int之后加final，表示最后一次覆写</li>
<li>如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使运行的是派生类中的函数版本也是如此。因此如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致</li>
<li>如果一个派生类函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用被解析为对派生类版本自身的调用，从而导致无限递归，我们通过作用域运算符说明调用的是哪个虚函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">name</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> basename;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream &amp;os)</span></span>&#123;os&lt;&lt;basename;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string basename = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream &amp;os)</span></span>&#123;base::<span class="built_in">print</span>(os);os&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i;&#125;<span class="comment">//必须有base：：否则会递归无限调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="15-4抽象基类"><a href="#15-4抽象基类" class="headerlink" title="15.4抽象基类"></a>15.4抽象基类</h3><hr>
<ol>
<li>我们可以定义一个类只用来存放一些数据，在这种类上定义一个函数将会变得没有意义，因此我们可以将这个函数定义为纯虚函数，告诉用户这个函数没有意义</li>
<li>我们在虚函数最后写上=0，就可以将一个虚函数说明为纯虚函数</li>
<li>纯虚函数的类不能实例化对象，但是我们定义初始化成员变量的构造函数，以供它的派生类使用，同时定义虚函数，让他的派生类实现该接口</li>
<li>纯虚函数的类是抽象基类。抽象基类负责定义接口，我们不能抽象基类的对象，但是可以定义派生类的对象，前提是这些类覆盖了这些纯虚函数</li>
<li>将一个类的派生类定义为一个抽象基类通常是一种重构的方法，可以将操作和数据从基类移动到这个类中，从而改变继承体系，而且一般情况下重构过后代码也不需要改变，但需要重新编译</li>
</ol>
<h3 id="15-5访问控制和继承"><a href="#15-5访问控制和继承" class="headerlink" title="15.5访问控制和继承"></a>15.5访问控制和继承</h3><hr>
<ol>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权</li>
<li>派生类的友元和成员不能直接访问基类的protected，只能访问派生类继承而来的protected成员</li>
<li>通过定义派生类的友元函数就能访问基类 的protected变量显然是不合理的，派生类的友元只能访问由派生类继承而来的属于派生类对象自己的原来的protected成员</li>
<li>某个类对其继承而来的成员的访问权限收到两个因素影响，一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符</li>
<li>派生列表中的private不影响派生类的访问权限</li>
<li>派生列表中的private控制派生类用户（包括派生类的派生类）对基类成员的访问权限，如果派生列表中是private的，则派生类的用户不能访问派生类成员的基类部分</li>
<li>派生列表中的类型不会影响派生类内成员和派生类友元对基类成员的访问（都已经继承到自己的类内了,private的不能访问，public和protected可以访问），但当其他用户使用派生类的对象时，认为从基类继承的成员都是 private的，不能访问 </li>
<li>派生类向基类转换的可访问性就遵从一个原则：是否可以访问基类的公有成员，可以就能转换，不行就不能转换，详情参看544页</li>
<li>友元的权限和类中的成员的权限相同</li>
<li>基类的友元可以访问其派生类中基类的部分，这有点奇怪，但是是正确的</li>
<li>如果一个类是另外一个类的友元，那么前者的派生类是不能继承友元关系的；<strong>每个类负责控制各自成员的访问权限（包括定义友元）</strong>,派生访问说明符控制自己继承的基类的访问权限</li>
<li>只要一个类定义了友元，那这个友元就能访问这个类的成员，哪怕这个类的成员成为了其派生类的一部分</li>
<li>通过using声明，我们可以改变派生类继承的某个名字的访问级别</li>
<li>派生类只能为那些它可以访问的名字提供using声明</li>
<li>struct默认是pulic继承的，而class默认是私有继承的；class和struct唯一的区别就是默认成员访问说明符及默认派生访问说明符：除此之外，再无其他不同之处</li>
</ol>
<h3 id="15-6继承中的类作用域"><a href="#15-6继承中的类作用域" class="headerlink" title="15.6继承中的类作用域"></a>15.6继承中的类作用域</h3><hr>
<ol>
<li><p>派生类的作用域嵌套在基类的作用域之内，所以可以使用基类中名字而不需要用A::这种形式访问</p>
</li>
<li><p>我们能使用哪些成员是由静态类型决定的，即使动态类型不一样</p>
</li>
<li><p>如果我们声明了一个基类的对象，该对象就算动态绑定到了它的派生类上，但是它还是只能调用自己的public的成员函数，因为它只会在自己基类的作用域中搜索合适的匹配的函数，而不能在派生类作用域中搜索可用的函数</p>
</li>
<li><p>派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域的名字将隐藏定义在外层作用域（基类内）的名字，<strong>派生了的成员将隐藏同名的基类成员</strong> <strong><em>注意：这不是重载,而是隐藏</em></strong></p>
</li>
<li><p>通过作用域运算符来使用隐藏的成员</p>
</li>
<li><p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</p>
</li>
<li><p><strong>名字查找先于类型匹配</strong>,因此内层定义的函数会隐藏基类定义的函数，而不管是否类型匹配，不构成重载，从而出错。（换句话说，如果能在派生类内找到名字就会直接使用对应名字，只有内层作用域中没有，才会在外层作用域，也就是基类中查找名字）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Deriverd d1;</span><br><span class="line">d1.<span class="built_in">memfcn</span>();<span class="comment">//错误 内层memfcn隐藏外层memfcn，不能传入参数</span></span><br><span class="line">d1.Base::<span class="built_in">memfcn</span>();<span class="comment">//正确，显示的调用，说明范围    </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>根据静态类型，找相应的作用域的函数，若是虚函数，则在运行时确定找哪一个覆盖的版本（不是隐藏）</strong>                         </p>
</li>
<li><p>只有调用虚函数才可能发生动态绑定，如果调用的是非虚函数，其静态类型就能决定调用的是哪个函数（才有可能发生隐藏的现象）</p>
</li>
<li><p>对于在基类重载的函数来说，其派生类不能只覆盖其中一个函数，不然这一个派生类的函数就会隐藏其他同名的重载的函数，所以书上说：要么全部覆盖基类中重载的函数，要么一个不覆盖（这个问题对应基类指针进行动态绑定就不存在了）</p>
</li>
<li><p>解决上述问题的办法是采用using说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(istream&amp;)</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(string s)</span></span>&#123;cout&lt;&lt; s&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>&#123;cout&lt;&lt;<span class="string">&quot;whatever&quot;</span>;&#125;;</span><br><span class="line">    <span class="keyword">using</span> B::A;<span class="comment">//加上这一个就行了，不加不行</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    B &amp; b = d;</span><br><span class="line">    b.<span class="built_in">A</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">//b虽然绑到了d上，但是搜索的作用域是静态类型决定的，不会发生隐藏的现象，如果是虚函数，只会发生动态绑定的过程</span></span><br><span class="line">    d.<span class="built_in">A</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">//这就不行，因为d是D的对象，名字查找找到是D的作用域，因为名字查找发生在类型匹配之前，一个override的A隐藏了所有的A，就会出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>一个原则：不要让派生类中的函数隐藏了基类中的同名函数</strong>,即使是override的函数也可能隐藏基类中其他同名的重载的函数                                                                                                                                                                             </p>
</li>
</ol>
<h3 id="15-7构造函数与拷贝控制"><a href="#15-7构造函数与拷贝控制" class="headerlink" title="15.7构造函数与拷贝控制"></a>15.7构造函数与拷贝控制</h3><ol>
<li><p>析构函数需要定义为虚函数，因为当我们delete一个动态分配的派生类对象时，会调用该派生类的析构函数，但是这个派生类可能是用基类的指针指向的，我们delete p相当于调用基类的析构函数，这时候必须能动态绑定到派生类上，调用派生类的override的析构函数，所以必须将基类的虚构函数待会故意为virtual的</p>
</li>
<li><p>简而言之<strong>如果我们删除的是一个指向派生类对象的基类指针，则需要析构函数</strong> ,口诀：调用虚函数，动态绑定 </p>
</li>
<li><p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为</p>
</li>
<li><p><strong>编译器会向上调用基类的合成的构造函数（包括拷贝构造和默认的构造函数），合成的析构函数（这个析构函数还会是虚函数），合成的拷贝构造函数</strong>，</p>
</li>
<li><p>虚析构函数将阻止合成移动操作</p>
</li>
<li><p>复习：<strong>只要定义了自己的拷贝控制成员和析构函数（说明我们要自己控制生成对象和销毁对象的方法），编译器都不会合成移动操作（也是一种默认生成和销毁对象的方式），就像编译器也不会合成默认的拷贝构造函数</strong></p>
</li>
<li><p>派生类的（合成的）构造函数不停的运行其基类的（合成的）构造函数，直到所有值被初始化</p>
</li>
<li><p>类似的，（合成的）拷贝构造函数使用其基类的（合成的）拷贝构造函数，直到完成拷贝</p>
</li>
<li><p>是不是合成的都无所谓，重要但是函数能够访问相应的成员</p>
</li>
<li><p>没有移动 操作意味着它的派生类也没有</p>
</li>
<li><p>删除的拷贝控制和基类的关系是：如果基类中没有处理基类成员的方法，那么派生类相应的拷贝控制成员，移动控制成员都要定义为删除的；甚至因为析构函数是删除的，不可访问的，派生类无法删除基类部分的成员，就只能把它的构造函数和拷贝控制成员都要被定义成删除的<strong>这都是我们自定义的情况</strong></p>
</li>
<li><p>如果基类不支持移动操作，派生类的移动构造函数也会是删除的</p>
</li>
<li><p><strong>总而言之，基类没有默认构造，拷贝构造，移动构造函数，派生类也不会定义相关的操作，而是都用合成的版本</strong></p>
</li>
<li><p>复习：我们可以这么理解：当我们为一个类定义拷贝构造函数或者移动构造函数时，意味着我们要自定义类的成员初始化的方法，那么合成的移动构造函数或者拷贝构造函数就会失效；当我们定义一个析构函数时，说明我们需要自定义销毁成员的方法，那么合成移动构造函数就会造成一些问题，因为我们无法确保我们自定义的析构函数能很好的处理移动过来的东西，用拷贝构造函数只是拷贝，这样就不会发生意外，所以<strong>有自定义析构函数就不会有合成的移动构造函数（或者是删除的）</strong></p>
</li>
<li><p>派生类对象的基类部分是自动销毁的</p>
</li>
<li><p>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象</p>
</li>
<li><p>当为派生类定义拷贝或者移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分</p>
</li>
<li><p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝(或者移动)基类部分，则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝构造函数</p>
</li>
<li><p>与上面的逻辑相同，赋值运算符也是如此，<strong>无论基类中的xx是合成的还是自定义的，在派生类中，我们都显式的调用，为派生类的基类部分赋值</strong></p>
</li>
<li><p>与构造函数及赋值运算符不同，基类部分会被隐式的销毁，派生类析构函数只需要销毁由派生类自己分配的资源；销毁顺序和创建顺序相反，派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后       </p>
</li>
<li><p>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本，执行最上层的虚函数版本，就是这个构造函数所在的类的版本</p>
</li>
<li><p>复习：</p>
<ul>
<li>如果一个类有数据成员不能默认构造，拷贝，复制或销毁，则对应的成员函数将被定义为删除的</li>
<li><strong>一个成员有删除的或者不可访问的析构函数会导致合成的默认构造函数和拷贝构造函数定义为删除的；因为我们不能建立一个无法销毁的对象</strong></li>
</ul>
<p>如果我们不声明自己的拷贝控制成员，编译器总会为我们合成这些操作（即使它是删除的）；如果声明了，就不会合成了；默认构造函数也是如此，自己定义就不会有合成版本的了，除非显式的声明合成版本的默认构造函数（ = default）</p>
<p>​         和拷贝控制成员和默认构造函数不同，编译器不会为某些类合成移动操作；如果一个类定义了自己的拷贝构造函数，拷贝赋值运算符或者析构函数，编译器就不会为他合成移动构造函数和移动赋值运算符了</p>
<p>​    如果移动操作可能被定义为删除的函数，编译器就不会合成它们</p>
<p>​    如果一个类定义了一个移动构造函数（移动赋值运算符），则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的</p>
<p>​    定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认的被定义为删除的</p>
</li>
<li><p>类可以继承其直接基类的构造函数；类不能继承默认，拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器为派生类合成它们</p>
</li>
<li><p>派生类继承基类构造函数的方式是提供一条注明了直接基类名的using声明语句</p>
</li>
<li><p>对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数</p>
</li>
<li><p>当一个基类构造函数含有实参，继承这个构造函数的派生类会生成多个构造函数，每个构造函数省略掉一个含有默认实参的形参</p>
</li>
<li><p>继承的构造函数不会被作为用户定义的构造函数来用，因此一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数      </p>
<p>​    </p>
</li>
</ol>
<h3 id="15-8-容器与继承"><a href="#15-8-容器与继承" class="headerlink" title="15.8  容器与继承"></a>15.8  容器与继承</h3><ol>
<li>在容器中直接放入派生类的对象会被“切掉”，push_back也是通过向插入迭代器赋值，调用拷贝赋值运算符存入对象，因此派生类对象可以被push_back到vector中，但是会丢掉派生类部分</li>
<li>我们在容器中放置（智能）指针而非对象，这些指针指向对象的动态类型可能是基类类型，也可能是派生类类型</li>
<li>复习：用mutilset定义严格弱序和unique指针定义删除器时都需要在&lt;&gt;中声明指向谓词（函数）的指针 &lt; xxx,  decltype(func) * &gt; item( &amp;func)</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Itk之PointSet</title>
    <url>/post/f8b294b7/</url>
    <content><![CDATA[<ol>
<li>用<code>TransformPhysucalPointToIndex(point,pixelIndex)</code>将point点坐标映射到Index上</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将点坐标转化为Index</span></span><br><span class="line"><span class="keyword">typedef</span> itk::Point&lt; <span class="keyword">double</span>, ImageType::ImageDimension &gt; PointType;</span><br><span class="line">pintType piont = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">ImageType::IndexType pixelIndex;</span><br><span class="line"><span class="keyword">bool</span> isInside = image-&gt;<span class="built_in">TransformPhysicalPointToIndex</span>( point, pixelIndex ); <span class="keyword">if</span> ( isInside ) &#123;</span><br><span class="line">ImageType::PixelType pixelValue = image-&gt;<span class="built_in">GetPixel</span>( pixelIndex ); pixelValue += <span class="number">5</span>; image-&gt;<span class="built_in">SetPixel</span>( pixelIndex, pixelValue ); &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol start="2">
<li>从缓冲获得图片  </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=========================================================================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright NumFOCUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> *  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         http://www.apache.org/licenses/LICENSE-2.0.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *  limitations under the License.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *=========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This example illustrates how to import data into the \doxygen&#123;Image&#125;</span></span><br><span class="line"><span class="comment">// class. This is particularly useful for interfacing with other software</span></span><br><span class="line"><span class="comment">// systems. Many systems use a contiguous block of memory as a buffer</span></span><br><span class="line"><span class="comment">// for image pixel data. The current example assumes this is the case and</span></span><br><span class="line"><span class="comment">// feeds the buffer into an \doxygen&#123;ImportImageFilter&#125;, thereby producing an</span></span><br><span class="line"><span class="comment">// image as output.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Here we create a synthetic image with a centered sphere in</span></span><br><span class="line"><span class="comment">// a locally allocated buffer and pass this block of memory to the</span></span><br><span class="line"><span class="comment">// \code&#123;ImportImageFilter&#125;. This example is set up so that on execution, the</span></span><br><span class="line"><span class="comment">// user must provide the name of an output file as a command-line argument.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// \index&#123;itk::ImportImageFilter!Instantiation&#125;</span></span><br><span class="line"><span class="comment">// \index&#123;itk::ImportImageFilter!Header&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// First, the header file of the \doxygen&#123;ImportImageFilter&#125; class must be</span></span><br><span class="line"><span class="comment">// included.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkImage.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkImportImageFilter.h&quot;</span></span></span><br><span class="line"><span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkImageFileWriter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;  outputImageFile&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Next, we select the data type used to represent the image pixels. We</span></span><br><span class="line">  <span class="comment">// assume that the external block of memory uses the same data type to</span></span><br><span class="line">  <span class="comment">// represent the pixels.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PixelType = <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Dimension = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> ImageType = itk::Image&lt;PixelType, Dimension&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The type of the \code&#123;ImportImageFilter&#125; is instantiated in the</span></span><br><span class="line">  <span class="comment">// following line.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!Instantiation&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> ImportFilterType = itk::ImportImageFilter&lt;PixelType, Dimension&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// A filter object created using the \code&#123;New()&#125; method is then</span></span><br><span class="line">  <span class="comment">// assigned to a \code&#123;SmartPointer&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!Pointer&#125;</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!New()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  ImportFilterType::Pointer importFilter = ImportFilterType::<span class="built_in">New</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This filter requires the user to specify the size of the image to be</span></span><br><span class="line">  <span class="comment">// produced as output.  The \code&#123;SetRegion()&#125; method is used to this end.</span></span><br><span class="line">  <span class="comment">// The image size should exactly match the number of pixels available in the</span></span><br><span class="line">  <span class="comment">// locally allocated buffer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!SetRegion()&#125;</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!New()&#125;</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!New()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  ImportFilterType::SizeType size;</span><br><span class="line"></span><br><span class="line">  size[<span class="number">0</span>] = <span class="number">200</span>; <span class="comment">// size along X</span></span><br><span class="line">  size[<span class="number">1</span>] = <span class="number">200</span>; <span class="comment">// size along Y</span></span><br><span class="line">  size[<span class="number">2</span>] = <span class="number">200</span>; <span class="comment">// size along Z</span></span><br><span class="line"></span><br><span class="line">  ImportFilterType::IndexType start;</span><br><span class="line">  start.<span class="built_in">Fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  ImportFilterType::RegionType region;</span><br><span class="line">  region.<span class="built_in">SetIndex</span>(start);</span><br><span class="line">  region.<span class="built_in">SetSize</span>(size);</span><br><span class="line"></span><br><span class="line">  importFilter-&gt;<span class="built_in">SetRegion</span>(region);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The origin of the output image is specified with the \code&#123;SetOrigin()&#125;</span></span><br><span class="line">  <span class="comment">// method.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">const</span> itk::SpacePrecisionType origin[Dimension] = &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">  importFilter-&gt;<span class="built_in">SetOrigin</span>(origin);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The spacing of the image is passed with the \code&#123;SetSpacing()&#125; method.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="comment">// spacing isotropic volumes to 1.0</span></span><br><span class="line">  <span class="keyword">const</span> itk::SpacePrecisionType spacing[Dimension] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">  importFilter-&gt;<span class="built_in">SetSpacing</span>(spacing);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Next we allocate the memory block containing the pixel data to be</span></span><br><span class="line">  <span class="comment">// passed to the \code&#123;ImportImageFilter&#125;. Note that we use exactly the</span></span><br><span class="line">  <span class="comment">// same size that was specified with the \code&#123;SetRegion()&#125; method. In a</span></span><br><span class="line">  <span class="comment">// practical application, you may get this buffer from some other library</span></span><br><span class="line">  <span class="comment">// using a different data structure to represent the images.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> numberOfPixels = size[<span class="number">0</span>] * size[<span class="number">1</span>] * size[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">auto</span> *             localBuffer = <span class="keyword">new</span> PixelType[numberOfPixels];</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">double</span> radius = <span class="number">80.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Here we fill up the buffer with a binary sphere. We use simple</span></span><br><span class="line">  <span class="comment">// \code&#123;for()&#125; loops here, similar to those found in the C or FORTRAN</span></span><br><span class="line">  <span class="comment">// programming languages. Note that ITK</span></span><br><span class="line">  <span class="comment">// does not use \code&#123;for()&#125; loops in its internal code to access</span></span><br><span class="line">  <span class="comment">// pixels. All pixel access tasks are instead performed using an</span></span><br><span class="line">  <span class="comment">// \doxygen&#123;ImageIterator&#125; that supports the management of</span></span><br><span class="line">  <span class="comment">// n-dimensional images.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">double</span> radius2 = radius * radius;</span><br><span class="line">  PixelType *      it = localBuffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> z = <span class="number">0</span>; z &lt; size[<span class="number">2</span>]; z++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> dz =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(z) - <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(size[<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; size[<span class="number">1</span>]; y++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">double</span> dy =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(y) - <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(size[<span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; size[<span class="number">0</span>]; x++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> dx =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) - <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(size[<span class="number">0</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> d2 = dx * dx + dy * dy + dz * dz;</span><br><span class="line">        *it++ = (d2 &lt; radius2) ? <span class="number">255</span> : <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The buffer is passed to the \code&#123;ImportImageFilter&#125; with the</span></span><br><span class="line">  <span class="comment">// \code&#123;SetImportPointer()&#125; method. Note that the last argument of this</span></span><br><span class="line">  <span class="comment">// method specifies who will be responsible for deleting the memory block</span></span><br><span class="line">  <span class="comment">// once it is no longer in use. A \code&#123;false&#125; value indicates that the</span></span><br><span class="line">  <span class="comment">// \code&#123;ImportImageFilter&#125; will not try to delete the buffer when its</span></span><br><span class="line">  <span class="comment">// destructor is called. A \code&#123;true&#125; value, on the other hand, will allow</span></span><br><span class="line">  <span class="comment">// the filter to delete the memory block upon destruction of the import</span></span><br><span class="line">  <span class="comment">// filter.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// For the \code&#123;ImportImageFilter&#125; to appropriately delete the</span></span><br><span class="line">  <span class="comment">// memory block, the memory must be allocated with the C++</span></span><br><span class="line">  <span class="comment">// \code&#123;new()&#125; operator. Memory allocated with other memory</span></span><br><span class="line">  <span class="comment">// allocation mechanisms, such as C \code&#123;malloc&#125; or \code&#123;calloc&#125;, will not</span></span><br><span class="line">  <span class="comment">// be deleted properly by the \code&#123;ImportImageFilter&#125;. In</span></span><br><span class="line">  <span class="comment">// other words, it is the application programmer&#x27;s responsibility</span></span><br><span class="line">  <span class="comment">// to ensure that \code&#123;ImportImageFilter&#125; is only given</span></span><br><span class="line">  <span class="comment">// permission to delete the C++ \code&#123;new&#125; operator-allocated memory.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> importImageFilterWillOwnTheBuffer = <span class="literal">true</span>;</span><br><span class="line">  importFilter-&gt;<span class="built_in">SetImportPointer</span>(</span><br><span class="line">    localBuffer, numberOfPixels, importImageFilterWillOwnTheBuffer);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Finally, we can connect the output of this filter to a pipeline.</span></span><br><span class="line">  <span class="comment">// For simplicity we just use a writer here, but it could be any other</span></span><br><span class="line">  <span class="comment">// filter.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> WriterType = itk::ImageFileWriter&lt;ImageType&gt;;</span><br><span class="line">  WriterType::Pointer writer = WriterType::<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">  writer-&gt;<span class="built_in">SetFileName</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  writer-&gt;<span class="built_in">SetInput</span>(importFilter-&gt;<span class="built_in">GetOutput</span>());</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    writer-&gt;<span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> itk::ExceptionObject &amp; exp)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Exception caught !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; exp &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Note that we do not call \code&#123;delete&#125; on the buffer since we pass</span></span><br><span class="line">  <span class="comment">// \code&#123;true&#125; as the last argument of \code&#123;SetImportPointer()&#125;. Now the</span></span><br><span class="line">  <span class="comment">// buffer is owned by the \code&#123;ImportImageFilter&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>point set</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkPointSet.h&quot;</span></span></span><br><span class="line"><span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Then we must decide what type of value to associate with the</span></span><br><span class="line">  <span class="comment">//  points. This is generally called the \code&#123;PixelType&#125; in order to make</span></span><br><span class="line">  <span class="comment">//  the terminology consistent with the \code&#123;itk::Image&#125;. The PointSet is</span></span><br><span class="line">  <span class="comment">//  also templated over the dimension of the space in which the points are</span></span><br><span class="line">  <span class="comment">//  represented. The following declaration illustrates a typical</span></span><br><span class="line">  <span class="comment">//  instantiation of the PointSet class.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!Instantiation&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointSetType = itk::PointSet&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>, <span class="number">3</span>&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  A \code&#123;PointSet&#125; object is created by invoking the \code&#123;New()&#125; method</span></span><br><span class="line">  <span class="comment">//  on its type.  The resulting object must be assigned to a</span></span><br><span class="line">  <span class="comment">//  \code&#123;SmartPointer&#125;.  The PointSet is then reference-counted and can be</span></span><br><span class="line">  <span class="comment">//  shared by multiple objects. The memory allocated for the PointSet will</span></span><br><span class="line">  <span class="comment">//  be released when the number of references to the object is reduced to</span></span><br><span class="line">  <span class="comment">//  zero. This simply means that the user does not need to be concerned</span></span><br><span class="line">  <span class="comment">//  with invoking the \code&#123;Delete()&#125; method on this class.  In fact, the</span></span><br><span class="line">  <span class="comment">//  \code&#123;Delete()&#125; method should \textbf&#123;never&#125; be called directly within</span></span><br><span class="line">  <span class="comment">//  any of the reference-counted ITK classes.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!New()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!Pointer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointSetType::Pointer pointsSet = PointSetType::<span class="built_in">New</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Following the principles of Generic Programming, the \code&#123;PointSet&#125;</span></span><br><span class="line">  <span class="comment">//  class has a set of associated defined types to ensure that interacting</span></span><br><span class="line">  <span class="comment">//  objects can be declared with compatible types. This set of type</span></span><br><span class="line">  <span class="comment">//  definitions is commonly known as a set of \emph&#123;traits&#125;.  Among the</span></span><br><span class="line">  <span class="comment">//  traits of the \code&#123;PointSet&#125; class is \code&#123;PointType&#125;, which is used</span></span><br><span class="line">  <span class="comment">//  by the point set to represent points in space. The following declaration</span></span><br><span class="line">  <span class="comment">//  takes the point type as defined in the \code&#123;PointSet&#125; traits and</span></span><br><span class="line">  <span class="comment">//  renames it to be conveniently used in the global namespace.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!PointType&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointType = PointSetType::PointType;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;PointType&#125; can now be used to declare point objects to be</span></span><br><span class="line">  <span class="comment">//  inserted in the \code&#123;PointSet&#125;. Points are fairly small objects, so</span></span><br><span class="line">  <span class="comment">//  it is inconvenient to manage them with reference counting and smart</span></span><br><span class="line">  <span class="comment">//  pointers. They are simply instantiated as typical C++ classes. The Point</span></span><br><span class="line">  <span class="comment">//  class inherits the \code&#123;[]&#125; operator from the \code&#123;itk::Array&#125; class.</span></span><br><span class="line">  <span class="comment">//  This makes it possible to access its components using index notation.</span></span><br><span class="line">  <span class="comment">//  For efficiency&#x27;s sake no bounds checking is performed during index</span></span><br><span class="line">  <span class="comment">//  access. It is the user&#x27;s responsibility to ensure that the index used is</span></span><br><span class="line">  <span class="comment">//  in the range</span></span><br><span class="line">  <span class="comment">//  $\&#123;0,Dimension-1\&#125;$. Each of the components in the point is associated</span></span><br><span class="line">  <span class="comment">//  with space coordinates. The following code illustrates how to</span></span><br><span class="line">  <span class="comment">//  instantiate a point and initialize its components.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointType p0;</span><br><span class="line">  p0[<span class="number">0</span>] = <span class="number">-1.0</span>; <span class="comment">//  x coordinate</span></span><br><span class="line">  p0[<span class="number">1</span>] = <span class="number">-1.0</span>; <span class="comment">//  y coordinate</span></span><br><span class="line">  p0[<span class="number">2</span>] = <span class="number">0.0</span>;  <span class="comment">//  z coordinate</span></span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PointType p1;</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">0</span>] = <span class="number">1.0</span>; <span class="comment">// Point 1 = &#123; 1,-1,0 &#125;</span></span><br><span class="line">  p1[<span class="number">1</span>] = <span class="number">-1.0</span>;</span><br><span class="line">  p1[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PointType p2; <span class="comment">// Point 2 = &#123; 1,1,0 &#125;</span></span><br><span class="line">  p2[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">  p2[<span class="number">1</span>] = <span class="number">1.0</span>;</span><br><span class="line">  p2[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Points are inserted in the PointSet by using the \code&#123;SetPoint()&#125;</span></span><br><span class="line">  <span class="comment">//  method. This method requires the user to provide a unique identifier for</span></span><br><span class="line">  <span class="comment">//  the point. The identifier is typically an unsigned integer that will</span></span><br><span class="line">  <span class="comment">//  enumerate the points as they are being inserted. The following code</span></span><br><span class="line">  <span class="comment">//  shows how three points are inserted into the PointSet.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPoint()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  pointsSet-&gt;<span class="built_in">SetPoint</span>(<span class="number">0</span>, p0);</span><br><span class="line">  pointsSet-&gt;<span class="built_in">SetPoint</span>(<span class="number">1</span>, p1);</span><br><span class="line">  pointsSet-&gt;<span class="built_in">SetPoint</span>(<span class="number">2</span>, p2);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// It is possible to query the PointSet in order to determine how many</span></span><br><span class="line">  <span class="comment">// points have been inserted into it. This is done with the</span></span><br><span class="line">  <span class="comment">// \code&#123;GetNumberOfPoints()&#125; method as illustrated below.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetNumberOfPoints()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> numberOfPoints = pointsSet-&gt;<span class="built_in">GetNumberOfPoints</span>();</span><br><span class="line">  std::cout &lt;&lt; numberOfPoints &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Points can be read from the PointSet by using the \code&#123;GetPoint()&#125;</span></span><br><span class="line">  <span class="comment">// method and the integer identifier. The point is stored in a pointer</span></span><br><span class="line">  <span class="comment">// provided by the user. If the identifier provided does not match an</span></span><br><span class="line">  <span class="comment">// existing point, the method will return \code&#123;false&#125; and the contents of</span></span><br><span class="line">  <span class="comment">// the point will be invalid. The following code illustrates point access</span></span><br><span class="line">  <span class="comment">// using defensive programming.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPoint()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointType pp;</span><br><span class="line">  <span class="keyword">bool</span>      pointExists = pointsSet-&gt;<span class="built_in">GetPoint</span>(<span class="number">1</span>, &amp;pp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pointExists)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Point is = &quot;</span> &lt;&lt; pp &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \code&#123;GetPoint()&#125; and \code&#123;SetPoint()&#125; are not the most efficient</span></span><br><span class="line">  <span class="comment">// methods to access points in the PointSet. It is preferable to get direct</span></span><br><span class="line">  <span class="comment">// access to the internal point container defined by the \emph&#123;traits&#125; and</span></span><br><span class="line">  <span class="comment">// use iterators to walk sequentially over the list of points (as shown in</span></span><br><span class="line">  <span class="comment">// the following example).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过迭代器访问<code>pointsset</code>中的points容器（保存了点的位置信息）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=========================================================================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright NumFOCUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> *  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         http://www.apache.org/licenses/LICENSE-2.0.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *  limitations under the License.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *=========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  The \doxygen&#123;PointSet&#125; class uses an internal container to manage the</span></span><br><span class="line"><span class="comment">//  storage of \doxygen&#123;Point&#125;s. It is more efficient, in general, to manage</span></span><br><span class="line"><span class="comment">//  points by using the access methods provided directly on the points</span></span><br><span class="line"><span class="comment">//  container. The following example illustrates how to interact with the</span></span><br><span class="line"><span class="comment">//  point container and how to use point iterators.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkPointSet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> PointSetType = itk::PointSet&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>, <span class="number">3</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The type is defined by the \emph&#123;traits&#125; of the \code&#123;PointSet&#125;</span></span><br><span class="line">  <span class="comment">//  class. The following line conveniently takes the \code&#123;PointsContainer&#125;</span></span><br><span class="line">  <span class="comment">//  type from the \code&#123;PointSet&#125; traits and declares it in the global</span></span><br><span class="line">  <span class="comment">//  namespace.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!PointsContainer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointsContainer = PointSetType::PointsContainer;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The actual type of \code&#123;PointsContainer&#125; depends on what style of</span></span><br><span class="line">  <span class="comment">//  \code&#123;PointSet&#125; is being used. The dynamic \code&#123;PointSet&#125; uses</span></span><br><span class="line">  <span class="comment">//  \doxygen&#123;MapContainer&#125; while the static \code&#123;PointSet&#125; uses</span></span><br><span class="line">  <span class="comment">//  \doxygen&#123;VectorContainer&#125;. The vector and map containers are basically</span></span><br><span class="line">  <span class="comment">//  ITK wrappers around the \href&#123;http://www.sgi.com/tech/stl/&#125;&#123;STL&#125;</span></span><br><span class="line">  <span class="comment">//  classes \href&#123;http://www.sgi.com/tech/stl/Map.html&#125;&#123;\code&#123;std::map&#125;&#125;</span></span><br><span class="line">  <span class="comment">//  and \href&#123;http://www.sgi.com/tech/stl/Vector.html&#125;&#123;\code&#123;std::vector&#125;&#125;.</span></span><br><span class="line">  <span class="comment">//  By default, \code&#123;PointSet&#125; uses a static style, and therefore the</span></span><br><span class="line">  <span class="comment">//  default type of point container is \code&#123;VectorContainer&#125;.  Both map and</span></span><br><span class="line">  <span class="comment">//  vector containers are templated over the type of element they contain.</span></span><br><span class="line">  <span class="comment">//  In this case they are templated over \code&#123;PointType&#125;. Containers are</span></span><br><span class="line">  <span class="comment">//  reference counted objects, created with the \code&#123;New()&#125; method and</span></span><br><span class="line">  <span class="comment">//  assigned to a \doxygen&#123;SmartPointer&#125;. The following line creates a point</span></span><br><span class="line">  <span class="comment">//  container compatible with the type of the \code&#123;PointSet&#125; from which the</span></span><br><span class="line">  <span class="comment">//  trait has been taken.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!New()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Pointer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointsContainer::Pointer points = PointsContainer::<span class="built_in">New</span>();<span class="comment">//points是点集</span></span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \code&#123;Point&#125;s can now be defined using the \code&#123;PointType&#125; trait from</span></span><br><span class="line">  <span class="comment">//  the \code&#123;PointSet&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointType = PointSetType::PointType;</span><br><span class="line">  PointType p0;</span><br><span class="line">  PointType p1;</span><br><span class="line">  p0[<span class="number">0</span>] = <span class="number">-1.0</span>;</span><br><span class="line">  p0[<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">  p0[<span class="number">2</span>] = <span class="number">0.0</span>; <span class="comment">// Point 0 = &#123;-1,0,0 &#125;</span></span><br><span class="line">  p1[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">  p1[<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">  p1[<span class="number">2</span>] = <span class="number">0.0</span>; <span class="comment">// Point 1 = &#123; 1,0,0 &#125;</span></span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line">  <span class="comment">// point类型就是数组保存三个位置的参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The created points can be inserted in the \code&#123;PointsContainer&#125; using</span></span><br><span class="line">  <span class="comment">//  the generic method \code&#123;InsertElement()&#125; which requires an identifier</span></span><br><span class="line">  <span class="comment">//  to be provided for each point.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::VectorContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::MapContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> pointId = <span class="number">0</span>;</span><br><span class="line">  points-&gt;<span class="built_in">InsertElement</span>(pointId++, p0);</span><br><span class="line">  points-&gt;<span class="built_in">InsertElement</span>(pointId++, p1);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  PointSetType::Pointer pointSet = PointSetType::<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Finally, the \code&#123;PointsContainer&#125; can be assigned to the</span></span><br><span class="line">  <span class="comment">//  \code&#123;PointSet&#125;. This will substitute any previously existing</span></span><br><span class="line">  <span class="comment">//  \code&#123;PointsContainer&#125; assigned to the \code&#123;PointSet&#125;. The assignment</span></span><br><span class="line">  <span class="comment">//  is done using the \code&#123;SetPoints()&#125; method.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPoints()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  pointSet-&gt;<span class="built_in">SetPoints</span>(points);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;PointsContainer&#125; object can be obtained from the</span></span><br><span class="line">  <span class="comment">//  \code&#123;PointSet&#125; using the \code&#123;GetPoints()&#125; method.  This method</span></span><br><span class="line">  <span class="comment">//  returns a pointer to the actual container owned by the PointSet which is</span></span><br><span class="line">  <span class="comment">//  then assigned to a \code&#123;SmartPointer&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPoints()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Pointer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointsContainer::Pointer points2 = pointSet-&gt;<span class="built_in">GetPoints</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The most efficient way to sequentially visit the points is to use the</span></span><br><span class="line">  <span class="comment">//  iterators provided by PointsContainer. The \code&#123;Iterator&#125; type belongs</span></span><br><span class="line">  <span class="comment">//  to the traits of the PointsContainer classes. It behaves pretty much</span></span><br><span class="line">  <span class="comment">//  like the STL iterators.\footnote&#123;If you dig deep enough into the code,</span></span><br><span class="line">  <span class="comment">//  you will discover that these iterators are actually ITK wrappers around</span></span><br><span class="line">  <span class="comment">//  STL iterators.&#125;  The Points iterator is not a reference counted class,</span></span><br><span class="line">  <span class="comment">//  so it is created directly from the traits without using SmartPointers.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Iterator&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointsIterator = PointsContainer::Iterator;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The subsequent use of the iterator follows what you may expect from a</span></span><br><span class="line">  <span class="comment">//  STL iterator. The iterator to the first point is obtained from the</span></span><br><span class="line">  <span class="comment">//  container with the \code&#123;Begin()&#125; method and assigned to another</span></span><br><span class="line">  <span class="comment">//  iterator.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Begin()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointsIterator pointIterator = points-&gt;<span class="built_in">Begin</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;++&#125; operator on the iterator can be used to advance from one</span></span><br><span class="line">  <span class="comment">//  point to the next. The actual value of the Point to which the iterator</span></span><br><span class="line">  <span class="comment">//  is pointing can be obtained with the \code&#123;Value()&#125; method. The loop for</span></span><br><span class="line">  <span class="comment">//  walking through all the points can be controlled by comparing the</span></span><br><span class="line">  <span class="comment">//  current iterator with the iterator returned by the \code&#123;End()&#125; method</span></span><br><span class="line">  <span class="comment">//  of the PointsContainer. The following lines illustrate the typical loop</span></span><br><span class="line">  <span class="comment">//  for walking through the points.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!End()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Iterator&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointsIterator end = points-&gt;<span class="built_in">End</span>();</span><br><span class="line">  <span class="keyword">while</span> (pointIterator != end)</span><br><span class="line">  &#123;</span><br><span class="line">    PointType p = pointIterator.<span class="built_in">Value</span>(); <span class="comment">// access the point</span></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;         <span class="comment">// print the point</span></span><br><span class="line">    ++pointIterator;                     <span class="comment">// advance to next point</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Note that as in STL, the iterator returned by the \code&#123;End()&#125; method is</span></span><br><span class="line">  <span class="comment">//  not a valid iterator. This is called a past-end iterator in order to</span></span><br><span class="line">  <span class="comment">//  indicate that it is the value resulting from advancing one step after</span></span><br><span class="line">  <span class="comment">//  visiting the last element in the container.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The number of elements stored in a container can be queried with the</span></span><br><span class="line">  <span class="comment">//  \code&#123;Size()&#125; method. In the case of the PointSet, the following two</span></span><br><span class="line">  <span class="comment">//  lines of code are equivalent, both of them returning the number of</span></span><br><span class="line">  <span class="comment">//  points in the PointSet.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetNumberOfPoints()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPoints()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Size()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  std::cout &lt;&lt; pointSet-&gt;<span class="built_in">GetNumberOfPoints</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">Size</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改变点的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=========================================================================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright NumFOCUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> *  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         http://www.apache.org/licenses/LICENSE-2.0.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *  limitations under the License.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *=========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  The \doxygen&#123;PointSet&#125; class was designed to interact with the</span></span><br><span class="line"><span class="comment">//  \code&#123;Image&#125; class. For this reason it was found convenient to allow the</span></span><br><span class="line"><span class="comment">//  points in the set to hold values that could be computed from images. The</span></span><br><span class="line"><span class="comment">//  value associated with the point is referred as \code&#123;PixelType&#125; in order</span></span><br><span class="line"><span class="comment">//  to make it consistent with image terminology. Users can define the type as</span></span><br><span class="line"><span class="comment">//  they please thanks to the flexibility offered by the Generic Programming</span></span><br><span class="line"><span class="comment">//  approach used in the toolkit.  The \code&#123;PixelType&#125; is the first template</span></span><br><span class="line"><span class="comment">//  parameter of the PointSet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  \index&#123;itk::PointSet!PixelType&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkPointSet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The following code defines a particular type for a pixel type and</span></span><br><span class="line">  <span class="comment">//  instantiates a PointSet class with it.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PixelType = <span class="keyword">unsigned</span> <span class="keyword">short</span>; <span class="comment">//注意pixeltype从才是点的数据类型，PointType是点的位置</span></span><br><span class="line">  <span class="keyword">using</span> PointSetType = itk::PointSet&lt;PixelType, <span class="number">3</span>&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A point set is instantiated here</span></span><br><span class="line">  PointSetType::Pointer pointSet = PointSetType::<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Data can be inserted into the PointSet using the \code&#123;SetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//  method. This method requires the user to provide an identifier. The data</span></span><br><span class="line">  <span class="comment">//  in question will be associated to the point holding the same identifier.</span></span><br><span class="line">  <span class="comment">//  It is the user&#x27;s responsibility to verify the appropriate matching</span></span><br><span class="line">  <span class="comment">//  between inserted data and inserted points. The following line</span></span><br><span class="line">  <span class="comment">//  illustrates the use of the \code&#123;SetPointData()&#125; method.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> dataId = <span class="number">0</span>;</span><br><span class="line">  PixelType    value = <span class="number">79</span>;</span><br><span class="line">  pointSet-&gt;<span class="built_in">SetPointData</span>(dataId++, value);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Data associated with points can be read from the PointSet using the</span></span><br><span class="line">  <span class="comment">//  \code&#123;GetPointData()&#125; method. This method requires the user to provide</span></span><br><span class="line">  <span class="comment">//  the identifier to the point and a valid pointer to a location where the</span></span><br><span class="line">  <span class="comment">//  pixel data can be safely written. In case the identifier does not match</span></span><br><span class="line">  <span class="comment">//  any existing identifier on the PointSet the method will return</span></span><br><span class="line">  <span class="comment">//  \code&#123;false&#125; and the pixel value returned will be invalid. It is the</span></span><br><span class="line">  <span class="comment">//  user&#x27;s responsibility to check the returned boolean value before</span></span><br><span class="line">  <span class="comment">//  attempting to use it.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> found = pointSet-&gt;<span class="built_in">GetPointData</span>(dataId, &amp;value);</span><br><span class="line">  <span class="keyword">if</span> (found)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pixel value = &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;SetPointData()&#125; and \code&#123;GetPointData()&#125; methods are not the</span></span><br><span class="line">  <span class="comment">//  most efficient way to get access to point data. It is far more efficient</span></span><br><span class="line">  <span class="comment">//  to use the Iterators provided by the \code&#123;PointDataContainer&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Data associated with points is internally stored in</span></span><br><span class="line">  <span class="comment">//  \code&#123;PointDataContainer&#125;s.  In the same way as with points, the actual</span></span><br><span class="line">  <span class="comment">//  container type used depend on whether the style of the PointSet is</span></span><br><span class="line">  <span class="comment">//  static or dynamic. Static point sets will use an</span></span><br><span class="line">  <span class="comment">//  \doxygen&#123;VectorContainer&#125; while dynamic point sets will use an</span></span><br><span class="line">  <span class="comment">//  \doxygen&#123;MapContainer&#125;.  The type of the data container is defined as</span></span><br><span class="line">  <span class="comment">//  one of the traits in the PointSet. The following declaration illustrates</span></span><br><span class="line">  <span class="comment">//  how the type can be taken from the traits and used to conveniently</span></span><br><span class="line">  <span class="comment">//  declare a similar type on the global namespace.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!PointDataContainer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointDataContainer = PointSetType::PointDataContainer;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Using the type it is now possible to create an instance of the data</span></span><br><span class="line">  <span class="comment">//  container. This is a standard reference counted object, henceforth it</span></span><br><span class="line">  <span class="comment">//  uses the \code&#123;New()&#125; method for creation and assigns the newly created</span></span><br><span class="line">  <span class="comment">//  object to a SmartPointer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!New()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!Pointer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointDataContainer::Pointer pointData = PointDataContainer::<span class="built_in">New</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Pixel data can be inserted in the container with the method</span></span><br><span class="line">  <span class="comment">//  \code&#123;InsertElement()&#125;. This method requires an identified to be</span></span><br><span class="line">  <span class="comment">//  provided for each point data.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::VectorContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::MapContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> pointId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  PixelType value0 = <span class="number">34</span>;</span><br><span class="line">  PixelType value1 = <span class="number">67</span>;</span><br><span class="line"></span><br><span class="line">  pointData-&gt;<span class="built_in">InsertElement</span>(pointId++, value0);</span><br><span class="line">  pointData-&gt;<span class="built_in">InsertElement</span>(pointId++, value1);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Finally the PointDataContainer can be assigned to the PointSet. This</span></span><br><span class="line">  <span class="comment">//  will substitute any previously existing PointDataContainer on the</span></span><br><span class="line">  <span class="comment">//  PointSet. The assignment is done using the \code&#123;SetPointData()&#125; method.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  pointSet-&gt;<span class="built_in">SetPointData</span>(pointData);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The PointDataContainer can be obtained from the PointSet using the</span></span><br><span class="line">  <span class="comment">//  \code&#123;GetPointData()&#125; method.  This method returns a pointer (assigned</span></span><br><span class="line">  <span class="comment">//  to a SmartPointer) to the actual container owned by the PointSet.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointDataContainer::Pointer pointData2 = pointSet-&gt;<span class="built_in">GetPointData</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The most efficient way to sequentially visit the data associated with</span></span><br><span class="line">  <span class="comment">//  points is to use the iterators provided by \code&#123;PointDataContainer&#125;.</span></span><br><span class="line">  <span class="comment">//  The \code&#123;Iterator&#125; type belongs to the traits of the PointsContainer</span></span><br><span class="line">  <span class="comment">//  classes. The iterator is not a reference counted class, so it is just</span></span><br><span class="line">  <span class="comment">//  created directly from the traits without using SmartPointers.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!Iterator&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointDataIterator = PointDataContainer::Iterator;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The subsequent use of the iterator follows what you may expect from a</span></span><br><span class="line">  <span class="comment">//  STL iterator. The iterator to the first point is obtained from the</span></span><br><span class="line">  <span class="comment">//  container with the \code&#123;Begin()&#125; method and assigned to another</span></span><br><span class="line">  <span class="comment">//  iterator.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!Begin()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointDataIterator pointDataIterator = pointData2-&gt;<span class="built_in">Begin</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;++&#125; operator on the iterator can be used to advance from one</span></span><br><span class="line">  <span class="comment">//  data point to the next. The actual value of the PixelType to which the</span></span><br><span class="line">  <span class="comment">//  iterator is pointing can be obtained with the \code&#123;Value()&#125;</span></span><br><span class="line">  <span class="comment">//  method. The loop for walking through all the point data can be</span></span><br><span class="line">  <span class="comment">//  controlled by comparing the current iterator with the iterator returned</span></span><br><span class="line">  <span class="comment">//  by the \code&#123;End()&#125; method of the PointsContainer. The following lines</span></span><br><span class="line">  <span class="comment">//  illustrate the typical loop for walking through the point data.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!End()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!increment ++&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointDataIterator end = pointData2-&gt;<span class="built_in">End</span>();</span><br><span class="line">  <span class="keyword">while</span> (pointDataIterator != end)</span><br><span class="line">  &#123;</span><br><span class="line">    PixelType p = pointDataIterator.<span class="built_in">Value</span>(); <span class="comment">// access the pixel data</span></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;             <span class="comment">// print the pixel data</span></span><br><span class="line">    ++pointDataIterator;                     <span class="comment">// advance to next pixel/point</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Note that as in STL, the iterator returned by the \code&#123;End()&#125; method is</span></span><br><span class="line">  <span class="comment">//  not a valid iterator. This is called a \emph&#123;past-end&#125; iterator in order</span></span><br><span class="line">  <span class="comment">//  to indicate that it is the value resulting from advancing one step after</span></span><br><span class="line">  <span class="comment">//  visiting the last element in the container.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用RGB作为<code>PixelType</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkRGBPixel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkPointSet.h&quot;</span></span></span><br><span class="line"><span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Then, the pixel type can be defined by selecting the type to be used to</span></span><br><span class="line">  <span class="comment">//  represent each one of the RGB components.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::RGBPixel!Instantiation&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PixelType = itk::RGBPixel&lt;<span class="keyword">float</span>&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The newly defined pixel type is now used to instantiate the PointSet</span></span><br><span class="line">  <span class="comment">//  type and subsequently create a point set object.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointSetType = itk::PointSet&lt;PixelType, <span class="number">3</span>&gt;;</span><br><span class="line">  PointSetType::Pointer pointSet = PointSetType::<span class="built_in">New</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The following code generates a circle and assigns RGB values to</span></span><br><span class="line">  <span class="comment">//  the points. The components of the RGB values in this example are</span></span><br><span class="line">  <span class="comment">//  computed to represent the position of the points.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPoint()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointSetType::PixelType pixel; <span class="comment">//点的值</span></span><br><span class="line">  PointSetType::PointType point; <span class="comment">//点的位置</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>            pointId = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">double</span>        radius = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> angle = i * itk::Math::pi / <span class="number">180.0</span>;</span><br><span class="line">    point[<span class="number">0</span>] = radius * std::<span class="built_in">sin</span>(angle);</span><br><span class="line">    point[<span class="number">1</span>] = radius * std::<span class="built_in">cos</span>(angle);</span><br><span class="line">    point[<span class="number">2</span>] = <span class="number">1.0</span>;</span><br><span class="line">    pixel.<span class="built_in">SetRed</span>(point[<span class="number">0</span>] * <span class="number">2.0</span>);</span><br><span class="line">    pixel.<span class="built_in">SetGreen</span>(point[<span class="number">1</span>] * <span class="number">2.0</span>);</span><br><span class="line">    pixel.<span class="built_in">SetBlue</span>(point[<span class="number">2</span>] * <span class="number">2.0</span>);</span><br><span class="line">    pointSet-&gt;<span class="built_in">SetPoint</span>(pointId, point);</span><br><span class="line">    pointSet-&gt;<span class="built_in">SetPointData</span>(pointId, pixel);</span><br><span class="line">    pointId++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  All the points on the PointSet are visited using the following code.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPoints()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!points iterator&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!iterating points&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointIterator = PointSetType::PointsContainer::ConstIterator;</span><br><span class="line">  PointIterator pointIterator = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">Begin</span>();<span class="comment">//获得点集的容器</span></span><br><span class="line">  PointIterator pointEnd = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">End</span>();</span><br><span class="line">  <span class="keyword">while</span> (pointIterator != pointEnd)</span><br><span class="line">  &#123;</span><br><span class="line">    point = pointIterator.<span class="built_in">Value</span>();</span><br><span class="line">    std::cout &lt;&lt; point &lt;&lt; std::endl;</span><br><span class="line">    ++pointIterator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Note that here the \code&#123;ConstIterator&#125; was used instead of the</span></span><br><span class="line">  <span class="comment">//  \code&#123;Iterator&#125; since the pixel values are not expected to be modified.</span></span><br><span class="line">  <span class="comment">//  ITK supports const-correctness at the API level.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  All the pixel values on the PointSet are visited using the following</span></span><br><span class="line">  <span class="comment">//  code.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!data iterator&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!iterating point data&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointDataIterator = PointSetType::PointDataContainer::ConstIterator;</span><br><span class="line">  PointDataIterator pixelIterator = pointSet-&gt;<span class="built_in">GetPointData</span>()-&gt;<span class="built_in">Begin</span>();<span class="comment">//获得点值的容器</span></span><br><span class="line">  PointDataIterator pixelEnd = pointSet-&gt;<span class="built_in">GetPointData</span>()-&gt;<span class="built_in">End</span>();</span><br><span class="line">  <span class="keyword">while</span> (pixelIterator != pixelEnd)</span><br><span class="line">  &#123;</span><br><span class="line">    pixel = pixelIterator.<span class="built_in">Value</span>();</span><br><span class="line">    std::cout &lt;&lt; pixel &lt;&lt; std::endl;</span><br><span class="line">    ++pixelIterator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Again, please note the use of the  \code&#123;ConstIterator&#125; instead of the</span></span><br><span class="line">  <span class="comment">//  \code&#123;Iterator&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;ConstIterator&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;const-correctness&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vector作为PixelType</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=========================================================================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright NumFOCUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> *  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         http://www.apache.org/licenses/LICENSE-2.0.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *  limitations under the License.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *=========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This example illustrates how a point set can be parameterized to manage a</span></span><br><span class="line"><span class="comment">//  particular pixel type. It is quite common to associate vector values with</span></span><br><span class="line"><span class="comment">//  points for producing geometric representations.  The following code shows</span></span><br><span class="line"><span class="comment">//  how vector values can be used as the pixel type on the PointSet class. The</span></span><br><span class="line"><span class="comment">//  \doxygen&#123;Vector&#125; class is used here as the pixel type. This class is</span></span><br><span class="line"><span class="comment">//  appropriate for representing the relative position between two points. It</span></span><br><span class="line"><span class="comment">//  could then be used to manage displacements, for example.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  \index&#123;itk::PointSet!Vector pixels&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  In order to use the vector class it is necessary to include its header</span></span><br><span class="line"><span class="comment">//  file along with the header of the point set.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkVector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkPointSet.h&quot;</span></span></span><br><span class="line"><span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \begin&#123;floatingfigure&#125;[rlp]&#123;6cm&#125;</span></span><br><span class="line">  <span class="comment">//    \centering</span></span><br><span class="line">  <span class="comment">//    \includegraphics[width=4cm]&#123;PointSetWithVectors&#125;</span></span><br><span class="line">  <span class="comment">//    \caption[PointSet with Vectors as PixelType]&#123;Vectors as</span></span><br><span class="line">  <span class="comment">//    PixelType.\label&#123;fig:PointSetWithVectors&#125;&#125;</span></span><br><span class="line">  <span class="comment">//  \end&#123;floatingfigure&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;Vector&#125; class is templated over the type used to represent</span></span><br><span class="line">  <span class="comment">//  the spatial coordinates and over the space dimension.  Since the</span></span><br><span class="line">  <span class="comment">//  PixelType is independent of the PointType, we are free to select any</span></span><br><span class="line">  <span class="comment">//  dimension for the vectors to be used as pixel type. However, for the</span></span><br><span class="line">  <span class="comment">//  sake of producing an interesting example, we will use vectors that</span></span><br><span class="line">  <span class="comment">//  represent displacements of the points in the PointSet. Those vectors</span></span><br><span class="line">  <span class="comment">//  are then selected to be of the same dimension as the PointSet.\newline</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::Vector!itk::PointSet&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Dimension = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">using</span> PixelType = itk::Vector&lt;<span class="keyword">float</span>, Dimension&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Then we use the PixelType (which are actually Vectors) to instantiate</span></span><br><span class="line">  <span class="comment">//  the PointSet type and subsequently create a PointSet object.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointSetType = itk::PointSet&lt;PixelType, Dimension&gt;;</span><br><span class="line">  PointSetType::Pointer pointSet = PointSetType::<span class="built_in">New</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The following code is generating a sphere and assigning vector values</span></span><br><span class="line">  <span class="comment">//  to the points. The components of the vectors in this example are</span></span><br><span class="line">  <span class="comment">//  computed to represent the tangents to the circle as shown in</span></span><br><span class="line">  <span class="comment">//  Figure~\ref&#123;fig:PointSetWithVectors&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPoint()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointSetType::PixelType tangent;</span><br><span class="line">  PointSetType::PointType point;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>     pointId = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">double</span> radius = <span class="number">300.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> angle = i * itk::Math::pi / <span class="number">180.0</span>;</span><br><span class="line">    point[<span class="number">0</span>] = radius * std::<span class="built_in">sin</span>(angle);</span><br><span class="line">    point[<span class="number">1</span>] = radius * std::<span class="built_in">cos</span>(angle);</span><br><span class="line">    point[<span class="number">2</span>] = <span class="number">1.0</span>; <span class="comment">// flat on the Z plane</span></span><br><span class="line">    tangent[<span class="number">0</span>] = std::<span class="built_in">cos</span>(angle);</span><br><span class="line">    tangent[<span class="number">1</span>] = -std::<span class="built_in">sin</span>(angle);</span><br><span class="line">    tangent[<span class="number">2</span>] = <span class="number">0.0</span>; <span class="comment">// flat on the Z plane</span></span><br><span class="line">    pointSet-&gt;<span class="built_in">SetPoint</span>(pointId, point);</span><br><span class="line">    pointSet-&gt;<span class="built_in">SetPointData</span>(pointId, tangent);</span><br><span class="line">    pointId++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  We can now visit all the points and use the vector on the pixel values</span></span><br><span class="line">  <span class="comment">//  to apply a displacement on the points. This is along the spirit of what</span></span><br><span class="line">  <span class="comment">//  a deformable model could do at each one of its iterations.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!PointIterator&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPoints()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointDataIterator = PointSetType::PointDataContainer::ConstIterator;</span><br><span class="line">  PointDataIterator pixelIterator = pointSet-&gt;<span class="built_in">GetPointData</span>()-&gt;<span class="built_in">Begin</span>();</span><br><span class="line">  PointDataIterator pixelEnd = pointSet-&gt;<span class="built_in">GetPointData</span>()-&gt;<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> PointIterator = PointSetType::PointsContainer::Iterator;</span><br><span class="line">  PointIterator pointIterator = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">Begin</span>();</span><br><span class="line">  PointIterator pointEnd = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (pixelIterator != pixelEnd &amp;&amp; pointIterator != pointEnd)</span><br><span class="line">  &#123;</span><br><span class="line">    pointIterator.<span class="built_in">Value</span>() = pointIterator.<span class="built_in">Value</span>() + pixelIterator.<span class="built_in">Value</span>();</span><br><span class="line">    ++pixelIterator;</span><br><span class="line">    ++pointIterator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Note that the \code&#123;ConstIterator&#125; was used here instead of the normal</span></span><br><span class="line">  <span class="comment">//  \code&#123;Iterator&#125; since the pixel values are only intended to be read and</span></span><br><span class="line">  <span class="comment">//  not modified. ITK supports const-correctness at the API level.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;ConstIterator&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;const-correctness&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \doxygen&#123;Vector&#125; class has overloaded the \code&#123;+&#125; operator with</span></span><br><span class="line">  <span class="comment">//  the \doxygen&#123;Point&#125;. In other words, vectors can be added to points in</span></span><br><span class="line">  <span class="comment">//  order to produce new points.  This property is exploited in the center</span></span><br><span class="line">  <span class="comment">//  of the loop in order to update the points positions with a single</span></span><br><span class="line">  <span class="comment">//  statement.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!PointIterator&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  We can finally visit all the points and print out the new values</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  pointIterator = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">Begin</span>();</span><br><span class="line">  pointEnd = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">End</span>();</span><br><span class="line">  <span class="keyword">while</span> (pointIterator != pointEnd)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; pointIterator.<span class="built_in">Value</span>() &lt;&lt; std::endl;</span><br><span class="line">    ++pointIterator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Note that \doxygen&#123;Vector&#125; is not the appropriate class for</span></span><br><span class="line">  <span class="comment">//  representing normals to surfaces and gradients of functions. This is due</span></span><br><span class="line">  <span class="comment">//  to the way vectors behave under affine transforms. ITK has a</span></span><br><span class="line">  <span class="comment">//  specific class for representing normals and function gradients. This is</span></span><br><span class="line">  <span class="comment">//  the \doxygen&#123;CovariantVector&#125; class.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Itk</tag>
        <tag>医学图像处理</tag>
      </tags>
  </entry>
</search>
