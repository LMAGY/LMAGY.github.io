<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HPE综述</title>
    <url>/post/f4697f57/</url>
    <content><![CDATA[<h1 id="Monocular-Human-Pose-Estimation-A-Survey-of-Deep-Learning-based-Methods"><a href="#Monocular-Human-Pose-Estimation-A-Survey-of-Deep-Learning-based-Methods" class="headerlink" title="Monocular Human Pose Estimation: A Survey of Deep Learning-based Methods"></a>Monocular Human Pose Estimation: A Survey of Deep Learning-based Methods</h1><h2 id="HPE-类别"><a href="#HPE-类别" class="headerlink" title="HPE 类别"></a>HPE 类别</h2><ol>
<li>generative（human body model-based)：<br>人体模型结构作为先验，几何上从不同视角投影到二位或三维空间，高维参数空间用回归的方式优化</li>
<li>discriminative (human body model-free)<br>从输入源直接学习一个映射，或者搜索现有案例(不用人体模型)；更快但是对没有训练过的姿态健壮性不足<span id="more"></span></li>
</ol>
<hr>
<p>多人pose estimation</p>
<ol>
<li><p>top-down<br>先探测人，产生位置的bounding box</p>
</li>
<li><p>bottom-up</p>
<p>先预测每个人所有的身体部位，再用人体模型拟合或者其他算法进行分组</p>
<p>当人变多时top-down计算花费明显提高，但如果有大规模的重叠，bottom-up方法在重组肢体上可能会遇到问题</p>
</li>
</ol>
<hr>
<ol>
<li><p>regression-based<br>直接从输入图片map关节坐标，或则得到人体模型参数</p>
</li>
<li><p>dectection-based(中间生成关节位置图像块或热图)   </p>
<p>将身体部位当作探测目标依据两个经常使用概念：关节部位的图像块和热图</p>
<p>小区域表示鲁棒性更强；小区域的检测结果限制了最终关节坐标的精度</p>
</li>
</ol>
<hr>
<ol>
<li><p>one-stage</p>
</li>
<li><p>multi-stage</p>
<p>有中间监督；例如先检测人的位置再顾及人体姿势</p>
<p>3D的HPE先在2d表面预测关节位置再将它们拓展到3D空间</p>
</li>
</ol>
<h3 id="人体模型"><a href="#人体模型" class="headerlink" title="人体模型"></a>人体模型</h3><p>一个成熟的人体模型不必包含所有身体特征，但是需要满足构建和描述人体姿势的特殊任务的需求</p>
<ol>
<li><p>骨架模型</p>
<p>代表一系列的关节位置和相应的遵从人体骨架结构的肢体方向</p>
<p>也可以描述为一个图，顶点代表关节，用边代表骨架结构中关节的链接和约束</p>
</li>
<li><p>轮廓模型</p>
<p>早期用的比较多</p>
</li>
<li><p>体模型</p>
<p>早期是圆锥圆柱，现在都用mesh</p>
</li>
</ol>
<hr>
<h2 id="2D人体姿态估计"><a href="#2D人体姿态估计" class="headerlink" title="2D人体姿态估计"></a>2D人体姿态估计</h2><h3 id="2D单人姿态估计"><a href="#2D单人姿态估计" class="headerlink" title="2D单人姿态估计"></a>2D单人姿态估计</h3><ol>
<li>先检测出单人，依据标注的人的中心位置和身体比例从原始图像中剪裁</li>
<li>regression-based 方法通过一个端到端的框架直接学习和预测坐标位置</li>
<li>detection-based方法先通过学习关节的或身体部位的矩形框，或者热图(每个都通过一个一关节位置为中心的2D高斯分布来显式一个关节位置)预测出身体部位的大致位置，再进行回归</li>
<li>Soft-argmax函数能将热图转化为关节坐标；将一个dectection-based网络变成一个可微分的回归网络</li>
</ol>
<h4 id="Regression-based-methods"><a href="#Regression-based-methods" class="headerlink" title="Regression-based methods"></a>Regression-based methods</h4><p>直接回归出坐标，缺点太多</p>
<h4 id="Detection-based-methods"><a href="#Detection-based-methods" class="headerlink" title="Detection-based methods"></a>Detection-based methods</h4><p>每个关节占据一个热图通道用一个一目标关节位置为中心的2D高斯分布</p>
<p>因为热图表示比坐标表示更有鲁棒性，大部分最近的研究都基于热图表示</p>
<p>有大量的工作在做这个方向</p>
<hr>
<h2 id="2D多人姿态估计"><a href="#2D多人姿态估计" class="headerlink" title="2D多人姿态估计"></a>2D多人姿态估计</h2><p>需要同时进行detection和localization</p>
<h3 id="Top-down-methods"><a href="#Top-down-methods" class="headerlink" title="Top-down methods"></a>Top-down methods</h3><p>效果依赖人体目标检测的结果，速度较慢，大都是非实时的</p>
<h3 id="Bottom-up-methods"><a href="#Bottom-up-methods" class="headerlink" title="Bottom-up methods"></a>Bottom-up methods</h3><p>需要进行joint dection和joint candiate grouping</p>
<p>速度快，但是容易收到复杂背景和人体遮挡的影响</p>
<p>stoa是top-down但是速度慢</p>
<hr>
<h2 id="3D人体姿态估"><a href="#3D人体姿态估" class="headerlink" title="3D人体姿态估"></a>3D人体姿态估</h2><p>单眼相机应用非常广泛，深度神经网络有能力预测dense depth和sparse depth points</p>
<h3 id="model-free-methods"><a href="#model-free-methods" class="headerlink" title="model-free methods"></a>model-free methods</h3><ol>
<li>直接将图片映射到3D位置</li>
<li>从预测的2D姿态上接着预测深度信息</li>
</ol>
<h3 id="Model-based-methods"><a href="#Model-based-methods" class="headerlink" title="Model-based methods"></a>Model-based methods</h3><ol>
<li>有很多工作基于SMPL(一个人体模型)，估计人体3D参数</li>
<li>运动学模型的运用也很广泛</li>
<li>还有自监督学习（可以研究的一个方向)</li>
<li>latent 3D pose model</li>
</ol>
<hr>
<h2 id="3D多人姿态估计"><a href="#3D多人姿态估计" class="headerlink" title="3D多人姿态估计"></a>3D多人姿态估计</h2><ol>
<li>研究方向很新工作较少</li>
<li>大都是多阶段</li>
</ol>
<hr>
<h2 id="数据集和评估指标"><a href="#数据集和评估指标" class="headerlink" title="数据集和评估指标"></a>数据集和评估指标</h2><h3 id="2D人体姿态估计数据集"><a href="#2D人体姿态估计数据集" class="headerlink" title="2D人体姿态估计数据集"></a>2D人体姿态估计数据集</h3><ol>
<li>FILC</li>
<li>LSP</li>
<li>MPII</li>
<li>COCO</li>
<li>AIC-HKD</li>
<li>Penn Action</li>
<li>J-HMDB</li>
<li>PoseTrack</li>
</ol>
<h3 id="2D人体姿态估计评价指标"><a href="#2D人体姿态估计评价指标" class="headerlink" title="2D人体姿态估计评价指标"></a>2D人体姿态估计评价指标</h3><ol>
<li><p>Percentage of Correct Parts(PCP)</p>
</li>
<li><p>Percentage of Correct Keypoints(PCK)</p>
</li>
<li><p>AP</p>
<p>每个点是单独算precision的，最后算所有点的平均</p>
</li>
<li><p>GFLOPs(速度)</p>
</li>
</ol>
<hr>
<h3 id="3D人体姿态估计数据集"><a href="#3D人体姿态估计数据集" class="headerlink" title="3D人体姿态估计数据集"></a>3D人体姿态估计数据集</h3><ol>
<li><p>HumanEva-I&amp;IIDatasets</p>
<p>有采集的3D坐标</p>
</li>
<li><p>Human3.6Mdataset</p>
</li>
<li><p>TNT15 Dataset</p>
</li>
<li><p>MPI-INF-3DHP</p>
</li>
<li><p>TotalCapture Dataset</p>
</li>
<li><p>MARCOnI Dataset(乱)</p>
</li>
<li><p>Panoptic Dataset</p>
</li>
<li><p>3DPW Dataset</p>
</li>
</ol>
<h3 id="3D人体姿态估计的评价指标"><a href="#3D人体姿态估计的评价指标" class="headerlink" title="3D人体姿态估计的评价指标"></a>3D人体姿态估计的评价指标</h3><ol>
<li>Mean Per Joint Positon Error(MPJPE)</li>
<li>PCK和AUC</li>
</ol>
]]></content>
      <categories>
        <category>HPE</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>CV</tag>
        <tag>python</tag>
        <tag>survey</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/post/d87f7e0c/</url>
    <content><![CDATA[<p>这是一个简单的测试，说明问题<span id="more"></span></p>
<p><img src="/post/d87f7e0c/background.png" alt="background"></p>
]]></content>
  </entry>
  <entry>
    <title>在这里</title>
    <url>/post/4f46e11/</url>
    <content><![CDATA[<p>javascript是一门充满活力、简单易用的语言，又是一门具有许多复杂微妙技术的语言。即使是经验丰富的javascript开发者，如果没有认真学习的话，也无法真正理解它们，这就是javascript的矛盾之处。由于javascript不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。不满足于只是让代码正常工作，而是想要弄清楚为什么，勇于挑战这条崎岖颠簸的少有人走的路，拥抱整个javascript</p>
<span id="more"></span>后面的内容在首页不显示，只显示到<!--more-->这里

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>重载运算与类型转换</title>
    <url>/post/undefined/</url>
    <content><![CDATA[<h3 id="14-1基本概念"><a href="#14-1基本概念" class="headerlink" title="14.1基本概念"></a><span id="more"></span>14.1基本概念</h3><ol>
<li><p>当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的参数数量比运算对象的数量少一个。</p>
</li>
<li><p>当重载的运算符不是成员函数时，首先他不能定义两个内置类型，其参数和运算对象一样多</p>
</li>
<li><p>复习：逗号表达式先对左侧求值，然后把结果扔掉，返回右侧表达式的值，若右侧表达式是左值，最终的求值结果也是左值</p>
</li>
<li><p>我们可以将运算符作用于类型正确的实参，从而间接方式“调用”重载的运算符函数；也可以像调用普通函数一样直接调用运算符函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">data1 + data2;</span><br><span class="line"><span class="keyword">operator</span>+(data1,data2); <span class="comment">//这两种方法等价</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为&amp;&amp; ||的短路求值属性，和逗号运算符的求值顺序无法保留下来，因此我们不建议重载他们</p>
</li>
<li><p>不重载逗号运算符和取址运算符的另外一个原因是，C++已经规定了他们作用于类类型对象时的含义；因为有了内置含义，所以一般来说他们不应该被重载</p>
</li>
<li><p>应该使用与内置类型一致的含义</p>
</li>
<li><p>逻辑运算和关系运算应该返回bool，算数运算符应该返回一个类类型的值，赋值运算符和复合运算符应该返回左侧运算对象的引用</p>
</li>
<li><p>只有当操作的含义对于用户来说清晰明了时才使用运算符</p>
</li>
<li><p>如果类由算数运算符或者位运算符，最好也提供对应的复合赋值运算，比如有+最好同时定义+=</p>
</li>
<li><p>运算符可以作为类的成员函数，也可以声明为一个普通的非成员函数</p>
<ul>
<li>赋值(= ),下标([ ]),调用(( ))和成员访问箭头(-&gt;)必须是成员</li>
<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同</li>
<li>改变对象状态的运算符或者给定类型密切相关的运算符，如递增，递减和解引用运算符，通常应该是成员</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算数,相等性，关系和位运算符等，因此他们通常应该是普通的非成员函数</li>
</ul>
</li>
<li><p>如果我们提供含有类对象的混合类型表达式，则运算符必须定义为非成员函数</p>
</li>
<li><p>对一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数</p>
</li>
</ol>
<h3 id="14-2输入和输出运算符"><a href="#14-2输入和输出运算符" class="headerlink" title="14.2输入和输出运算符"></a>14.2输入和输出运算符</h3><ol>
<li>通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符</li>
<li>如果我们希望为类自定义IO运算符，则<strong>必须将其定义为非成员函数</strong>，且应该声明为友元</li>
<li>输入运算符必须处理输入可能失败的情况，而输出运算符不需要</li>
<li>当读取操作发生错误时，输入运算符应该负责从错误中恢复</li>
<li>我们可以用io库的那些failbit，eofbit，和badbit来获取流的状态（P279）</li>
<li>eof( )表示流到末尾，bad()表示流损坏，二者都会导致fail为true</li>
</ol>
<h3 id="14-3-算数和关系运算符"><a href="#14-3-算数和关系运算符" class="headerlink" title="14.3 算数和关系运算符"></a>14.3 算数和关系运算符</h3><ol>
<li><p>如果类定义了算数运算符，则他一般也会定义一个对应的复合赋值运算符</p>
</li>
<li><p>如果同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值运算符来实现算数运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sale_data <span class="keyword">operator</span>+(<span class="keyword">const</span> Sale_data &amp;lhs,<span class="keyword">const</span> Sale_data &amp;rhs)&#123;</span><br><span class="line">    Sales_data sum = lhs;<span class="comment">//</span></span><br><span class="line">    sum += rhs; <span class="comment">//调用复合赋值运算符</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个类定义了operator==，则这个类也应该定义operator!=;我们只让其中一个工作，另外一个则调用真正工作的运算符 <code>return !(rhs==lhs);</code>这种就可以</p>
</li>
</ol>
<h3 id="14-4赋值运算符"><a href="#14-4赋值运算符" class="headerlink" title="14.4赋值运算符"></a>14.4赋值运算符</h3><ol>
<li><p>除了拷贝赋值和移动赋值运算符外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	StrVec &amp;<span class="keyword">operator</span>=(initializer_list&lt;string&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无论形参类型是什么，<strong>赋值运算符都必须定义为成员函数</strong></p>
</li>
<li><p>复合赋值运算符不非是类的成员，但我们倾向与把包括复合赋值在内的所有赋值运算都定义在类的内部，返回其左侧对象的引用</p>
</li>
<li><p>注意赋值运算符完成构造和析构两个过程</p>
</li>
</ol>
<h3 id="14-5下标运算符"><a href="#14-5下标运算符" class="headerlink" title="14.5下标运算符"></a>14.5下标运算符</h3><ol>
<li>如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用<code>string &amp; operator[](size_t n);</code>和<code>const string&amp; operator[](size_t n) const</code></li>
</ol>
<h3 id="14-6递增和递减运算符"><a href="#14-6递增和递减运算符" class="headerlink" title="14.6递增和递减运算符"></a>14.6递增和递减运算符</h3><ol>
<li><p>因为他们改变的是类的成员，所以建议将其设定为成员函数</p>
</li>
<li><p>应该同时定义前置版本和后置版本</p>
</li>
<li><p>后置的版本接受一个额外的（不被使用）的int类型的形参，编译器会默认给它实参0；我们不会使用这个形参，其唯一的作用就是区分前置版本和后置版本的函数，而不是要真的实现后置版本时参与计算</p>
</li>
<li><p>后置运算符返回对象的原值，返回的是值而非引用（需要先保存原来的值，再在最后返回），再将原对象进行++操作，调用前置版本的++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;       <span class="comment">//记录当前的值</span></span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回之前记录的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li>如果显示调用后置版本的++,我们必须给它一个int以区分前置版本的 ++</li>
</ol>
<h3 id="14-7成员访问运算符"><a href="#14-7成员访问运算符" class="headerlink" title="14.7成员访问运算符"></a>14.7成员访问运算符</h3><ol>
<li><p>箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址</p>
</li>
<li><p>可以将箭头运算符理解为如下 形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">point.<span class="keyword">operator</span>-&gt;()-&gt;mem;<span class="comment">//注意这可能是一个套娃，因为point.operator-&gt;()返回的也可能是一个</span></span><br><span class="line"><span class="comment">//类(指针类）的对象，碰到了-&gt;又开始调用重载的operator-&gt;，知道point成为一个指针，真的指向了mem成员</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重载-&gt;可以认为是改变了从哪个对象中获取成员</p>
</li>
<li><p>我自己感觉只有行为类似指针的类才需要重载-&gt;，而一般的数值类不会重载-&gt;</p>
</li>
<li><p>-&gt;最终返回的是一个地址，之后他会继续使用-&gt;,直到用内置版本的-&gt;</p>
</li>
</ol>
<h3 id="14-8函数调用运算符"><a href="#14-8函数调用运算符" class="headerlink" title="14.8函数调用运算符"></a>14.8函数调用运算符</h3><ol>
<li><p>如果类定义了调用运算符，则该类对象称作函数对象 。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样）</p>
</li>
<li><p>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别</p>
</li>
<li><p>函数对象类通常含有一些数据成员，被用于定制调用运算符中的操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream&amp; o = cout,<span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>):<span class="built_in">os</span>(o),<span class="built_in">sep</span>(c)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span> </span>&#123;os&lt;&lt;s&lt;&lt;sep&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;      <span class="comment">//将输入写入目的流</span></span><br><span class="line">    <span class="keyword">char</span> sep;         <span class="comment">//用于将不同输出隔开的字符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数对象常常作为泛型算法的实参，例如可以用for_each算法</p>
</li>
<li><p>A(a)会生成一个临时对象</p>
</li>
<li><p>lambda是函数对象，和写一个类再生成一个临时的函数对象的写法没有区别</p>
</li>
<li><p>lambda表达式产生的类不含默认构造函数,赋值运算符及默认析构；他是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员而定</p>
</li>
<li><p>标准库定义了一组表示算数运算符，关系运算符和逻辑运算符的类，每个类分别定义一个执行命名操作的调用运算符；这些类都被定义为模板的形式，可以为其指定具体的应用类型，这里的类型即为调用运算符的形参类型。例如,plus<string>加法运算作用于string对象；</string></p>
</li>
<li><p>标准库函数对象在functional头文件中</p>
</li>
<li><p>可以用函数对象代替默认运算符</p>
</li>
<li><p>指针类型不能进行关系比较，会产生未定义的行为，但我们能用标准库函数对象比较大小</p>
</li>
<li><p>关联容器使用less<key_value>对元素进行排序，因此我们可以定义一个指针的set，或者在map中使用指针作为关键值而无需声明less</key_value></p>
</li>
<li><p>复习：bind是一种函数适配器，它接受一个可调用对象，生成一个新的可调用对象，生成一个新的可调用对象来”适应“原对象的参数列表</p>
</li>
<li><p>复习：如果一个lambda包含return以外的任何语句，则编译器假定它返回一个void，此时若想说明返回的类型不是void，就要加上位置返回类型的说明。（如果只有一个return，则它会根据return的类型，自动判断应该返回的类型</p>
</li>
<li><p>for_each是只读的，除非传入引用并且改变引用的对象的值，其默认返回void</p>
</li>
<li><p>将标准库函数和bind联合使用形成谓词从而用在泛型算法中是一种常见的用法</p>
</li>
<li><p>c++中可调用对象有：函数，函数指针，lambda表达式，bind创建的对象，以及重载了函数调用运算符的类（函数对象）</p>
</li>
<li><p>lambda有自己唯一的未命名类类型；函数及函数指针的类型由返回值类型和实参类型决定</p>
</li>
<li><p>两个不同类型的可调用对象能共享同一张调用形式。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，如int (int  int )</p>
</li>
<li><p>向一个map中加入元素的方式最简单的有两种一个是<code>map.insert(&#123;a,b&#125;)</code>一个是<code>map.insert(make_pair(a,b))</code>,只要记住加入的是一个pair就行，第一种列表会自动转化为pair，等价于<code>pair&lt;A,B&gt;(a,b)</code></p>
</li>
<li><p>fuction&lt;调用形式&gt; f = 可调用对象，就可以将f变为可调用对象的副本，且统一可调用对象的类型为调用形式的类型</p>
</li>
<li><p>尽管可调用对象的类型各不相同，我们仍然能够把左右这些类型都存储在同一个<code>function&lt;int (int,int)&gt;</code>类型中，并且进行调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;string,function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;+&quot;</span>,add&#125;,         <span class="comment">//普通函数指针</span></span><br><span class="line">    &#123;<span class="string">&quot;-&quot;</span>,minus&lt;<span class="keyword">int</span>&gt;()&#125;,<span class="comment">//标准库函数对象；</span></span><br><span class="line">    &#123;<span class="string">&quot;/&quot;</span>,<span class="built_in">divide</span>()&#125;,    <span class="comment">//函数对象；</span></span><br><span class="line">    &#123;<span class="string">&quot;*&quot;</span>,[](<span class="keyword">int</span> i,<span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i*j;&#125;&#125;, <span class="comment">//未命名的lambda</span></span><br><span class="line">    &#123;<span class="string">&quot;%&quot;</span>,mod&#125;;        <span class="comment">//命名了的lambda对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只能说bind和标准库对象是绝配</p>
</li>
<li><p>复习：string的find函数会返回一个size_type类型的值表示下标，如果没找到就返回std::string::npos,npos是size_type可能取得的最大值</p>
</li>
<li><p>复习：能用stod转换的string必须是以+-012…9开头的string，因此一般我们用s.find_first_of获取第一个可以作为开头位置的pos，再用s.substr(pos)获得可以进行转换的子串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">char</span>,function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; functions&#123;&#123;<span class="string">&#x27;+&#x27;</span>,plus&lt;<span class="keyword">int</span>&gt;()&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,minus&lt;<span class="keyword">int</span>&gt;()&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,multiplies&lt;<span class="keyword">int</span>&gt;()&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,divides&lt;<span class="keyword">int</span>&gt;()&#125;&#125;;<span class="comment">//遇见不同的符号就会调用不同的函数</span></span><br><span class="line">   string expression;</span><br><span class="line">   <span class="keyword">while</span>(cin&gt;&gt;expression)&#123;</span><br><span class="line">       <span class="keyword">auto</span> pos = expression.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-*/&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> num1 = <span class="built_in">stoi</span>(expression.<span class="built_in">substr</span>(<span class="number">0</span>,pos));</span><br><span class="line">       <span class="keyword">int</span> num2 = <span class="built_in">stoi</span>(expression.<span class="built_in">substr</span>(pos+<span class="number">1</span>));</span><br><span class="line">       <span class="keyword">char</span> op = expression[pos];</span><br><span class="line">       <span class="keyword">auto</span> result = functions[op](num1,num2);</span><br><span class="line">       cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="14-9重载类型转换与运算符"><a href="#14-9重载类型转换与运算符" class="headerlink" title="14.9重载类型转换与运算符"></a>14.9重载类型转换与运算符</h3><ol>
<li>转换构造函数(只接受一个参数的非explicit构造函数)和类型转换运算符共同定义了类类型转换，这样的转换有时也被称作用户定义的类型转换（user-defined conversions）</li>
<li>一个类型转换函数必须是类的成员函数；他不能声明返回类型，形参列表也必须为空。因为它一般不改变待转换对象的内容，所以类型转换运算符一般被定义成const成员</li>
<li>无论类类型发生隐式转换前还是后，都可以进行内置类型转换，也就是说可以从 double转为int在转为类A，也可以从A转为int再转为double</li>
<li>因为转换是隐式进行的，所以没有参数；因为要转换成的类型就是返回的类型，所以不需要声明返回类型。</li>
<li>避免过度使用类型转换函数，可以设计普通的成员函数来代替</li>
<li>一般情况下，不会定义类型转换，但是定义向bool类型转换还是比较普遍的现象</li>
<li>为了防止莫名的类型转换运算符，C++11引入了显式的类型转换运算符，就是operator前加上explicit</li>
<li>当表达式被用作条件，编译器会将显式的类型转换自动的应用于它</li>
<li>向bool的类型转换通常在条件部分，这是explict也能进行隐式的转换，所以operator bool一般可以定义为explicit的</li>
<li>两个类不要定义相同的类型转换（A可以通过A的构造函数转换B为A，也可以通过B的类型转换运算符将B转换为A);也不要在类中定义两个及两个以上转换源或者转换目标是算数类型的转换</li>
<li>当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配是到底是哪个</li>
<li>总而言之，除了显式地向bool类型的转换之外，我们应该避免定义类型转换函数并尽可能的限制非显式构造函数</li>
<li>在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性 </li>
<li>简单来说，只要一个数能同时转化为两个函数都能调用的情况，就说明有二义性，只有被相同的函数调用时，转化的优先级才有意义；就是不能又可以转换为A又能转换为B，这样就会不知道调用哪个函数，从而产生二义性；如果它能确定只转换为一个用户定义的类型转换中的类型，那么优先级才有用</li>
<li>如果我们对同一个类提供了转换目标是算数类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题（类型转换为算数类型进行内置运算或者是直接调用重载运算符）</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象程序设计</title>
    <url>/post/fdd04c25/</url>
    <content><![CDATA[<p>No one is coming<span id="more"></span></p>
<p>###15.1 OOP：概述</p>
<ol>
<li>面向对象程序设计基于三个基本概念：数据抽象，继承和动态绑定</li>
<li>继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类，二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别</li>
<li>在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望他的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数</li>
<li>派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的</li>
<li>派生类列表中使用public关键字，可以把派生类对象完全当成基类的对象来使用</li>
<li>派生类必须在其内部所有重新定义的虚函数进行声明；派生类可以在这样的函数之前加上virtual,也可以不这么做；C++新标准允许派生类显示地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在函数的形参列表之后增加一个override关键字</li>
<li>在c++中，我们使用基类的引用或指针调用一个虚函数时将发生动态绑定</li>
</ol>
<h3 id="15-2定义基类和派生类"><a href="#15-2定义基类和派生类" class="headerlink" title="15.2定义基类和派生类"></a>15.2定义基类和派生类</h3><hr>
<ol>
<li><p>基类通常都应该定义为一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
</li>
<li><p>基类希望派生类进行覆盖的函数定义为虚函数，调用该函数根据对象进行动态的绑定</p>
</li>
<li><p>任何构造函数之外的非静态函数都可以是虚函数。如果基类一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数</p>
</li>
<li><p>关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义</p>
</li>
<li><p>派生类的成员函数不一定有权访问从基类继承而来的成员。派生类能访问公有成员，不能访问私有成员。protectd成员是基类的派生类有权访问该成员，同时禁止其他用户访问</p>
</li>
<li><p>派生类列表的形式是：一个冒号，后面紧跟以逗号分割的基类列表，每个基类前面可以有以下三种访问说明符：pulic,protected或者private</p>
</li>
<li><p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明（但不一定是重写）</p>
</li>
<li><p>如果派生是public的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将共有派生类型的对象绑定到基类的引用或者指针上。大多数类都只继承自一个类，这种形式的继承称作单继承</p>
</li>
<li><p>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本</p>
</li>
<li><p>复习：我们用&amp;和&amp;&amp;限制this是左值还是右值，放在函数形参列表之后（const之后）</p>
</li>
<li><p>我们可以在引用限定符后面添加一个关键字override表示其覆盖它继承的虚函数</p>
</li>
<li><p>在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在</p>
</li>
<li><p>编译器会隐式地执行派生类到基类的转换，对于基类的引用和指针都能绑定到派生类上，出现基类的地方派生类也都可以出现</p>
</li>
<li><p>派生类不能直接初始化从基类继承的成员，必须使用基类的构造函数初始化其基类部分（每个类控制自己的成员初始化过程）</p>
</li>
<li><p>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员</p>
</li>
<li><p>一个派生类对象一般有三个部分的数据：一是基类中的private，二是基类中的protected，三是自己的private；第一种只有它继承的基类的函数才能访问操作（构造函数也包括在内，所以要初始化这一部分的数据就需要用基类的构造函数，还必须是显示的调用），第二种和第三种它自己定义的函数也能访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>:</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="keyword">const</span> string&amp;,<span class="keyword">double</span>,<span class="keyword">size_t</span>,<span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span>)</span><span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> min_qiy = <span class="number">0</span> ; <span class="comment">//使用折扣政策的最低购买量</span></span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>; <span class="comment">//小数表示折扣额</span></span><br><span class="line">&#125;;</span><br><span class="line">Bulk_quote::<span class="built_in">Bulk_quote</span>(<span class="keyword">const</span> string &amp; book, <span class="keyword">double</span> p, <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):<span class="built_in">Quote</span>(book,p),<span class="built_in">min_qiy</span>(qty),<span class="built_in">discount</span>(disc) &#123;</span><br><span class="line">&#125; <span class="comment">//初始化分为两部分，一部分是基类中的成员一部分是派生类自己的成员</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类可以访问基类的公有成员和受保护成员，只有基类的函数才能访问基类的私有成员</p>
</li>
<li><p>派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员的方式和使用基类成员的方式没有什么不同</p>
</li>
<li><p><strong>关键概念：遵循基类的接口</strong>:每个类负责定义各自的接口。派生类对象不能直接初始化基类的成员，而是调用基类的构造函数来初始化它从基类中继承而来的成员</p>
</li>
<li><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的的唯一定义。不论从基类中派生出多少派生类，对于每个静态成员都存在唯一的实例；</p>
</li>
<li><p>静态成员遵循通用的访问规则，如果某静态成员是可访问的，我能通过基类使用它也可以通过派生类使用它</p>
</li>
<li><p>派生类的声明包括类名但是不包括它的派生列表</p>
</li>
<li><p>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明，因此一个类不能派生它本身</p>
</li>
<li><p>最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象</p>
</li>
<li><p>我们在类名后加上一个final，表示这个类不能被继承</p>
</li>
<li><p>理解基类和派生类之间的类型转换是理解面向对象编程的关键所在</p>
</li>
<li><p>当使用基类的引用或指针时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的,也可能是基类的子类</p>
</li>
<li><p><strong>指针和引用表达式有可能动态类型和静态类型不一样，因为虽然我们将指针和引用绑定到了一个基类上，但是实际调用时可能调用的是子类的对象（引用的是派生类的对象）。但是，不是说子类对象就能转换为基类对象，只有指针和引用这两个表达式能进行转换</strong></p>
</li>
<li><p>简而言之指针可能从A*类型变为A2 *类型，引用可能从A&amp; 变为A2&amp;,其中A2是A的派生类，A是A2的基类</p>
</li>
<li><p>一个基类的对象既可以以独立的形式存在，也可以以派生类对象的一部分存在，基类支持的，派生类都支持，所以派生类可以向基类转变，反之则不行</p>
</li>
<li><p>总而言之*<em>不存在基类向派生类的转换，在对象之间也不存在类型转换 *</em></p>
</li>
<li><p>当我们用一个派生类对象为一个基类对象初始化或赋值时（因为初始化和赋值接受的参数是const&amp;类型，所以可以将派生类对象绑定到基类引用上)只有该派生对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将会被<strong>切掉</strong> （忽略掉）</p>
</li>
<li><p>书上有总结，看536页吧</p>
</li>
</ol>
<h3 id="15-3虚函数"><a href="#15-3虚函数" class="headerlink" title="15.3虚函数"></a>15.3虚函数</h3><hr>
<ol>
<li>我们必须为每个虚函数都提供定义，而不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数</li>
<li>引用或指针的静态类型和动态类型不同这一事实正是C++语言支持多态性的根本所在</li>
<li>对非虚函数调用在编译时绑定。类似的，通过对象进行的函数（虚函数和非虚函数）调用也在编译时绑定</li>
<li>当且仅当通过指针和引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同</li>
<li>一旦某一个函数被声明成虚函数，则在所有的派生类中它都是虚函数（加不加virtual都行）</li>
<li>基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参和返回值必须与派生类中的形参严格匹配</li>
<li>如果我们在派生类中定义了和虚函数形参不同的函数，编译器会认为这是一个不同的函数，为了容易发现这个错误，我们可以用override关键字说明是派生类中的虚函数,此时如果我们没有覆盖已经存在的虚函数，编译器会报错</li>
<li>我们在const后面加上final，则之后任何尝试覆盖该函数的操作都将发生错误 ；在const，&amp;，&amp;&amp;，-&gt;int之后加final，表示最后一次覆写</li>
<li>如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使运行的是派生类中的函数版本也是如此。因此如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致</li>
<li>如果一个派生类函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用被解析为对派生类版本自身的调用，从而导致无限递归，我们通过作用域运算符说明调用的是哪个虚函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">name</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> basename;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream &amp;os)</span></span>&#123;os&lt;&lt;basename;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string basename = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream &amp;os)</span></span>&#123;base::<span class="built_in">print</span>(os);os&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i;&#125;<span class="comment">//必须有base：：否则会递归无限调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="15-4抽象基类"><a href="#15-4抽象基类" class="headerlink" title="15.4抽象基类"></a>15.4抽象基类</h3><hr>
<ol>
<li>我们可以定义一个类只用来存放一些数据，在这种类上定义一个函数将会变得没有意义，因此我们可以将这个函数定义为纯虚函数，告诉用户这个函数没有意义</li>
<li>我们在虚函数最后写上=0，就可以将一个虚函数说明为纯虚函数</li>
<li>纯虚函数的类不能实例化对象，但是我们定义初始化成员变量的构造函数，以供它的派生类使用，同时定义虚函数，让他的派生类实现该接口</li>
<li>纯虚函数的类是抽象基类。抽象基类负责定义接口，我们不能抽象基类的对象，但是可以定义派生类的对象，前提是这些类覆盖了这些纯虚函数</li>
<li>将一个类的派生类定义为一个抽象基类通常是一种重构的方法，可以将操作和数据从基类移动到这个类中，从而改变继承体系，而且一般情况下重构过后代码也不需要改变，但需要重新编译</li>
</ol>
<h3 id="15-5访问控制和继承"><a href="#15-5访问控制和继承" class="headerlink" title="15.5访问控制和继承"></a>15.5访问控制和继承</h3><hr>
<ol>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权</li>
<li>派生类的友元和成员不能直接访问基类的protected，只能访问派生类继承而来的protected成员</li>
<li>通过定义派生类的友元函数就能访问基类 的protected变量显然是不合理的，派生类的友元只能访问由派生类继承而来的属于派生类对象自己的原来的protected成员</li>
<li>某个类对其继承而来的成员的访问权限收到两个因素影响，一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符</li>
<li>派生列表中的private不影响派生类的访问权限</li>
<li>派生列表中的private控制派生类用户（包括派生类的派生类）对基类成员的访问权限，如果派生列表中是private的，则派生类的用户不能访问派生类成员的基类部分</li>
<li>派生列表中的类型不会影响派生类内成员和派生类友元对基类成员的访问（都已经继承到自己的类内了,private的不能访问，public和protected可以访问），但当其他用户使用派生类的对象时，认为从基类继承的成员都是 private的，不能访问 </li>
<li>派生类向基类转换的可访问性就遵从一个原则：是否可以访问基类的公有成员，可以就能转换，不行就不能转换，详情参看544页</li>
<li>友元的权限和类中的成员的权限相同</li>
<li>基类的友元可以访问其派生类中基类的部分，这有点奇怪，但是是正确的</li>
<li>如果一个类是另外一个类的友元，那么前者的派生类是不能继承友元关系的；<strong>每个类负责控制各自成员的访问权限（包括定义友元）</strong>,派生访问说明符控制自己继承的基类的访问权限</li>
<li>只要一个类定义了友元，那这个友元就能访问这个类的成员，哪怕这个类的成员成为了其派生类的一部分</li>
<li>通过using声明，我们可以改变派生类继承的某个名字的访问级别</li>
<li>派生类只能为那些它可以访问的名字提供using声明</li>
<li>struct默认是pulic继承的，而class默认是私有继承的；class和struct唯一的区别就是默认成员访问说明符及默认派生访问说明符：除此之外，再无其他不同之处</li>
</ol>
<h3 id="15-6继承中的类作用域"><a href="#15-6继承中的类作用域" class="headerlink" title="15.6继承中的类作用域"></a>15.6继承中的类作用域</h3><hr>
<ol>
<li><p>派生类的作用域嵌套在基类的作用域之内，所以可以使用基类中名字而不需要用A::这种形式访问</p>
</li>
<li><p>我们能使用哪些成员是由静态类型决定的，即使动态类型不一样</p>
</li>
<li><p>如果我们声明了一个基类的对象，该对象就算动态绑定到了它的派生类上，但是它还是只能调用自己的public的成员函数，因为它只会在自己基类的作用域中搜索合适的匹配的函数，而不能在派生类作用域中搜索可用的函数</p>
</li>
<li><p>派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域的名字将隐藏定义在外层作用域（基类内）的名字，<strong>派生了的成员将隐藏同名的基类成员</strong> <strong><em>注意：这不是重载,而是隐藏</em></strong></p>
</li>
<li><p>通过作用域运算符来使用隐藏的成员</p>
</li>
<li><p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</p>
</li>
<li><p><strong>名字查找先于类型匹配</strong>,因此内层定义的函数会隐藏基类定义的函数，而不管是否类型匹配，不构成重载，从而出错。（换句话说，如果能在派生类内找到名字就会直接使用对应名字，只有内层作用域中没有，才会在外层作用域，也就是基类中查找名字）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Deriverd d1;</span><br><span class="line">d1.<span class="built_in">memfcn</span>();<span class="comment">//错误 内层memfcn隐藏外层memfcn，不能传入参数</span></span><br><span class="line">d1.Base::<span class="built_in">memfcn</span>();<span class="comment">//正确，显示的调用，说明范围    </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>根据静态类型，找相应的作用域的函数，若是虚函数，则在运行时确定找哪一个覆盖的版本（不是隐藏）</strong>                         </p>
</li>
<li><p>只有调用虚函数才可能发生动态绑定，如果调用的是非虚函数，其静态类型就能决定调用的是哪个函数（才有可能发生隐藏的现象）</p>
</li>
<li><p>对于在基类重载的函数来说，其派生类不能只覆盖其中一个函数，不然这一个派生类的函数就会隐藏其他同名的重载的函数，所以书上说：要么全部覆盖基类中重载的函数，要么一个不覆盖（这个问题对应基类指针进行动态绑定就不存在了）</p>
</li>
<li><p>解决上述问题的办法是采用using说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(istream&amp;)</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(string s)</span></span>&#123;cout&lt;&lt; s&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>&#123;cout&lt;&lt;<span class="string">&quot;whatever&quot;</span>;&#125;;</span><br><span class="line">    <span class="keyword">using</span> B::A;<span class="comment">//加上这一个就行了，不加不行</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    B &amp; b = d;</span><br><span class="line">    b.<span class="built_in">A</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">//b虽然绑到了d上，但是搜索的作用域是静态类型决定的，不会发生隐藏的现象，如果是虚函数，只会发生动态绑定的过程</span></span><br><span class="line">    d.<span class="built_in">A</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">//这就不行，因为d是D的对象，名字查找找到是D的作用域，因为名字查找发生在类型匹配之前，一个override的A隐藏了所有的A，就会出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>一个原则：不要让派生类中的函数隐藏了基类中的同名函数</strong>,即使是override的函数也可能隐藏基类中其他同名的重载的函数                                                                                                                                                                             </p>
</li>
</ol>
<h3 id="15-7构造函数与拷贝控制"><a href="#15-7构造函数与拷贝控制" class="headerlink" title="15.7构造函数与拷贝控制"></a>15.7构造函数与拷贝控制</h3><ol>
<li><p>析构函数需要定义为虚函数，因为当我们delete一个动态分配的派生类对象时，会调用该派生类的析构函数，但是这个派生类可能是用基类的指针指向的，我们delete p相当于调用基类的析构函数，这时候必须能动态绑定到派生类上，调用派生类的override的析构函数，所以必须将基类的虚构函数待会故意为virtual的</p>
</li>
<li><p>简而言之<strong>如果我们删除的是一个指向派生类对象的基类指针，则需要析构函数</strong> ,口诀：调用虚函数，动态绑定 </p>
</li>
<li><p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为</p>
</li>
<li><p><strong>编译器会向上调用基类的合成的构造函数（包括拷贝构造和默认的构造函数），合成的析构函数（这个析构函数还会是虚函数），合成的拷贝构造函数</strong>，</p>
</li>
<li><p>虚析构函数将阻止合成移动操作</p>
</li>
<li><p>复习：<strong>只要定义了自己的拷贝控制成员和析构函数（说明我们要自己控制生成对象和销毁对象的方法），编译器都不会合成移动操作（也是一种默认生成和销毁对象的方式），就像编译器也不会合成默认的拷贝构造函数</strong></p>
</li>
<li><p>派生类的（合成的）构造函数不停的运行其基类的（合成的）构造函数，直到所有值被初始化</p>
</li>
<li><p>类似的，（合成的）拷贝构造函数使用其基类的（合成的）拷贝构造函数，直到完成拷贝</p>
</li>
<li><p>是不是合成的都无所谓，重要但是函数能够访问相应的成员</p>
</li>
<li><p>没有移动 操作意味着它的派生类也没有</p>
</li>
<li><p>删除的拷贝控制和基类的关系是：如果基类中没有处理基类成员的方法，那么派生类相应的拷贝控制成员，移动控制成员都要定义为删除的；甚至因为析构函数是删除的，不可访问的，派生类无法删除基类部分的成员，就只能把它的构造函数和拷贝控制成员都要被定义成删除的<strong>这都是我们自定义的情况</strong></p>
</li>
<li><p>如果基类不支持移动操作，派生类的移动构造函数也会是删除的</p>
</li>
<li><p><strong>总而言之，基类没有默认构造，拷贝构造，移动构造函数，派生类也不会定义相关的操作，而是都用合成的版本</strong></p>
</li>
<li><p>复习：我们可以这么理解：当我们为一个类定义拷贝构造函数或者移动构造函数时，意味着我们要自定义类的成员初始化的方法，那么合成的移动构造函数或者拷贝构造函数就会失效；当我们定义一个析构函数时，说明我们需要自定义销毁成员的方法，那么合成移动构造函数就会造成一些问题，因为我们无法确保我们自定义的析构函数能很好的处理移动过来的东西，用拷贝构造函数只是拷贝，这样就不会发生意外，所以<strong>有自定义析构函数就不会有合成的移动构造函数（或者是删除的）</strong></p>
</li>
<li><p>派生类对象的基类部分是自动销毁的</p>
</li>
<li><p>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象</p>
</li>
<li><p>当为派生类定义拷贝或者移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分</p>
</li>
<li><p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝(或者移动)基类部分，则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝构造函数</p>
</li>
<li><p>与上面的逻辑相同，赋值运算符也是如此，<strong>无论基类中的xx是合成的还是自定义的，在派生类中，我们都显式的调用，为派生类的基类部分赋值</strong></p>
</li>
<li><p>与构造函数及赋值运算符不同，基类部分会被隐式的销毁，派生类析构函数只需要销毁由派生类自己分配的资源；销毁顺序和创建顺序相反，派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后       </p>
</li>
<li><p>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本，执行最上层的虚函数版本，就是这个构造函数所在的类的版本</p>
</li>
<li><p>复习：</p>
<ul>
<li>如果一个类有数据成员不能默认构造，拷贝，复制或销毁，则对应的成员函数将被定义为删除的</li>
<li><strong>一个成员有删除的或者不可访问的析构函数会导致合成的默认构造函数和拷贝构造函数定义为删除的；因为我们不能建立一个无法销毁的对象</strong></li>
</ul>
<p>如果我们不声明自己的拷贝控制成员，编译器总会为我们合成这些操作（即使它是删除的）；如果声明了，就不会合成了；默认构造函数也是如此，自己定义就不会有合成版本的了，除非显式的声明合成版本的默认构造函数（ = default）</p>
<p>​         和拷贝控制成员和默认构造函数不同，编译器不会为某些类合成移动操作；如果一个类定义了自己的拷贝构造函数，拷贝赋值运算符或者析构函数，编译器就不会为他合成移动构造函数和移动赋值运算符了</p>
<p>​    如果移动操作可能被定义为删除的函数，编译器就不会合成它们</p>
<p>​    如果一个类定义了一个移动构造函数（移动赋值运算符），则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的</p>
<p>​    定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认的被定义为删除的</p>
</li>
<li><p>类可以继承其直接基类的构造函数；类不能继承默认，拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器为派生类合成它们</p>
</li>
<li><p>派生类继承基类构造函数的方式是提供一条注明了直接基类名的using声明语句</p>
</li>
<li><p>对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数</p>
</li>
<li><p>当一个基类构造函数含有实参，继承这个构造函数的派生类会生成多个构造函数，每个构造函数省略掉一个含有默认实参的形参</p>
</li>
<li><p>继承的构造函数不会被作为用户定义的构造函数来用，因此一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数      </p>
<p>​    </p>
</li>
</ol>
<h3 id="15-8-容器与继承"><a href="#15-8-容器与继承" class="headerlink" title="15.8  容器与继承"></a>15.8  容器与继承</h3><ol>
<li>在容器中直接放入派生类的对象会被“切掉”，push_back也是通过向插入迭代器赋值，调用拷贝赋值运算符存入对象，因此派生类对象可以被push_back到vector中，但是会丢掉派生类部分</li>
<li>我们在容器中放置（智能）指针而非对象，这些指针指向对象的动态类型可能是基类类型，也可能是派生类类型</li>
<li>复习：用mutilset定义严格弱序和unique指针定义删除器时都需要在&lt;&gt;中声明指向谓词（函数）的指针 &lt; xxx,  decltype(func) * &gt; item( &amp;func)</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Itk之PointSet</title>
    <url>/post/f8b294b7/</url>
    <content><![CDATA[<ol>
<li>用<code>TransformPhysucalPointToIndex(point,pixelIndex)</code>将point点坐标映射到Index上</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将点坐标转化为Index</span></span><br><span class="line"><span class="keyword">typedef</span> itk::Point&lt; <span class="keyword">double</span>, ImageType::ImageDimension &gt; PointType;</span><br><span class="line">pintType piont = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">ImageType::IndexType pixelIndex;</span><br><span class="line"><span class="keyword">bool</span> isInside = image-&gt;<span class="built_in">TransformPhysicalPointToIndex</span>( point, pixelIndex ); <span class="keyword">if</span> ( isInside ) &#123;</span><br><span class="line">ImageType::PixelType pixelValue = image-&gt;<span class="built_in">GetPixel</span>( pixelIndex ); pixelValue += <span class="number">5</span>; image-&gt;<span class="built_in">SetPixel</span>( pixelIndex, pixelValue ); &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol start="2">
<li>从缓冲获得图片  </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=========================================================================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright NumFOCUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> *  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         http://www.apache.org/licenses/LICENSE-2.0.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *  limitations under the License.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *=========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This example illustrates how to import data into the \doxygen&#123;Image&#125;</span></span><br><span class="line"><span class="comment">// class. This is particularly useful for interfacing with other software</span></span><br><span class="line"><span class="comment">// systems. Many systems use a contiguous block of memory as a buffer</span></span><br><span class="line"><span class="comment">// for image pixel data. The current example assumes this is the case and</span></span><br><span class="line"><span class="comment">// feeds the buffer into an \doxygen&#123;ImportImageFilter&#125;, thereby producing an</span></span><br><span class="line"><span class="comment">// image as output.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Here we create a synthetic image with a centered sphere in</span></span><br><span class="line"><span class="comment">// a locally allocated buffer and pass this block of memory to the</span></span><br><span class="line"><span class="comment">// \code&#123;ImportImageFilter&#125;. This example is set up so that on execution, the</span></span><br><span class="line"><span class="comment">// user must provide the name of an output file as a command-line argument.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// \index&#123;itk::ImportImageFilter!Instantiation&#125;</span></span><br><span class="line"><span class="comment">// \index&#123;itk::ImportImageFilter!Header&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// First, the header file of the \doxygen&#123;ImportImageFilter&#125; class must be</span></span><br><span class="line"><span class="comment">// included.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkImage.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkImportImageFilter.h&quot;</span></span></span><br><span class="line"><span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkImageFileWriter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;  outputImageFile&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Next, we select the data type used to represent the image pixels. We</span></span><br><span class="line">  <span class="comment">// assume that the external block of memory uses the same data type to</span></span><br><span class="line">  <span class="comment">// represent the pixels.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PixelType = <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Dimension = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> ImageType = itk::Image&lt;PixelType, Dimension&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The type of the \code&#123;ImportImageFilter&#125; is instantiated in the</span></span><br><span class="line">  <span class="comment">// following line.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!Instantiation&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> ImportFilterType = itk::ImportImageFilter&lt;PixelType, Dimension&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// A filter object created using the \code&#123;New()&#125; method is then</span></span><br><span class="line">  <span class="comment">// assigned to a \code&#123;SmartPointer&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!Pointer&#125;</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!New()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  ImportFilterType::Pointer importFilter = ImportFilterType::<span class="built_in">New</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This filter requires the user to specify the size of the image to be</span></span><br><span class="line">  <span class="comment">// produced as output.  The \code&#123;SetRegion()&#125; method is used to this end.</span></span><br><span class="line">  <span class="comment">// The image size should exactly match the number of pixels available in the</span></span><br><span class="line">  <span class="comment">// locally allocated buffer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!SetRegion()&#125;</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!New()&#125;</span></span><br><span class="line">  <span class="comment">// \index&#123;itk::ImportImageFilter!New()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  ImportFilterType::SizeType size;</span><br><span class="line"></span><br><span class="line">  size[<span class="number">0</span>] = <span class="number">200</span>; <span class="comment">// size along X</span></span><br><span class="line">  size[<span class="number">1</span>] = <span class="number">200</span>; <span class="comment">// size along Y</span></span><br><span class="line">  size[<span class="number">2</span>] = <span class="number">200</span>; <span class="comment">// size along Z</span></span><br><span class="line"></span><br><span class="line">  ImportFilterType::IndexType start;</span><br><span class="line">  start.<span class="built_in">Fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  ImportFilterType::RegionType region;</span><br><span class="line">  region.<span class="built_in">SetIndex</span>(start);</span><br><span class="line">  region.<span class="built_in">SetSize</span>(size);</span><br><span class="line"></span><br><span class="line">  importFilter-&gt;<span class="built_in">SetRegion</span>(region);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The origin of the output image is specified with the \code&#123;SetOrigin()&#125;</span></span><br><span class="line">  <span class="comment">// method.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">const</span> itk::SpacePrecisionType origin[Dimension] = &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">  importFilter-&gt;<span class="built_in">SetOrigin</span>(origin);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The spacing of the image is passed with the \code&#123;SetSpacing()&#125; method.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="comment">// spacing isotropic volumes to 1.0</span></span><br><span class="line">  <span class="keyword">const</span> itk::SpacePrecisionType spacing[Dimension] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">  importFilter-&gt;<span class="built_in">SetSpacing</span>(spacing);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Next we allocate the memory block containing the pixel data to be</span></span><br><span class="line">  <span class="comment">// passed to the \code&#123;ImportImageFilter&#125;. Note that we use exactly the</span></span><br><span class="line">  <span class="comment">// same size that was specified with the \code&#123;SetRegion()&#125; method. In a</span></span><br><span class="line">  <span class="comment">// practical application, you may get this buffer from some other library</span></span><br><span class="line">  <span class="comment">// using a different data structure to represent the images.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> numberOfPixels = size[<span class="number">0</span>] * size[<span class="number">1</span>] * size[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">auto</span> *             localBuffer = <span class="keyword">new</span> PixelType[numberOfPixels];</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">double</span> radius = <span class="number">80.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Here we fill up the buffer with a binary sphere. We use simple</span></span><br><span class="line">  <span class="comment">// \code&#123;for()&#125; loops here, similar to those found in the C or FORTRAN</span></span><br><span class="line">  <span class="comment">// programming languages. Note that ITK</span></span><br><span class="line">  <span class="comment">// does not use \code&#123;for()&#125; loops in its internal code to access</span></span><br><span class="line">  <span class="comment">// pixels. All pixel access tasks are instead performed using an</span></span><br><span class="line">  <span class="comment">// \doxygen&#123;ImageIterator&#125; that supports the management of</span></span><br><span class="line">  <span class="comment">// n-dimensional images.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">double</span> radius2 = radius * radius;</span><br><span class="line">  PixelType *      it = localBuffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> z = <span class="number">0</span>; z &lt; size[<span class="number">2</span>]; z++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> dz =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(z) - <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(size[<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; size[<span class="number">1</span>]; y++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">double</span> dy =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(y) - <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(size[<span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; size[<span class="number">0</span>]; x++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> dx =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) - <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(size[<span class="number">0</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> d2 = dx * dx + dy * dy + dz * dz;</span><br><span class="line">        *it++ = (d2 &lt; radius2) ? <span class="number">255</span> : <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The buffer is passed to the \code&#123;ImportImageFilter&#125; with the</span></span><br><span class="line">  <span class="comment">// \code&#123;SetImportPointer()&#125; method. Note that the last argument of this</span></span><br><span class="line">  <span class="comment">// method specifies who will be responsible for deleting the memory block</span></span><br><span class="line">  <span class="comment">// once it is no longer in use. A \code&#123;false&#125; value indicates that the</span></span><br><span class="line">  <span class="comment">// \code&#123;ImportImageFilter&#125; will not try to delete the buffer when its</span></span><br><span class="line">  <span class="comment">// destructor is called. A \code&#123;true&#125; value, on the other hand, will allow</span></span><br><span class="line">  <span class="comment">// the filter to delete the memory block upon destruction of the import</span></span><br><span class="line">  <span class="comment">// filter.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// For the \code&#123;ImportImageFilter&#125; to appropriately delete the</span></span><br><span class="line">  <span class="comment">// memory block, the memory must be allocated with the C++</span></span><br><span class="line">  <span class="comment">// \code&#123;new()&#125; operator. Memory allocated with other memory</span></span><br><span class="line">  <span class="comment">// allocation mechanisms, such as C \code&#123;malloc&#125; or \code&#123;calloc&#125;, will not</span></span><br><span class="line">  <span class="comment">// be deleted properly by the \code&#123;ImportImageFilter&#125;. In</span></span><br><span class="line">  <span class="comment">// other words, it is the application programmer&#x27;s responsibility</span></span><br><span class="line">  <span class="comment">// to ensure that \code&#123;ImportImageFilter&#125; is only given</span></span><br><span class="line">  <span class="comment">// permission to delete the C++ \code&#123;new&#125; operator-allocated memory.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> importImageFilterWillOwnTheBuffer = <span class="literal">true</span>;</span><br><span class="line">  importFilter-&gt;<span class="built_in">SetImportPointer</span>(</span><br><span class="line">    localBuffer, numberOfPixels, importImageFilterWillOwnTheBuffer);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Finally, we can connect the output of this filter to a pipeline.</span></span><br><span class="line">  <span class="comment">// For simplicity we just use a writer here, but it could be any other</span></span><br><span class="line">  <span class="comment">// filter.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> WriterType = itk::ImageFileWriter&lt;ImageType&gt;;</span><br><span class="line">  WriterType::Pointer writer = WriterType::<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">  writer-&gt;<span class="built_in">SetFileName</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  writer-&gt;<span class="built_in">SetInput</span>(importFilter-&gt;<span class="built_in">GetOutput</span>());</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    writer-&gt;<span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> itk::ExceptionObject &amp; exp)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Exception caught !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; exp &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Note that we do not call \code&#123;delete&#125; on the buffer since we pass</span></span><br><span class="line">  <span class="comment">// \code&#123;true&#125; as the last argument of \code&#123;SetImportPointer()&#125;. Now the</span></span><br><span class="line">  <span class="comment">// buffer is owned by the \code&#123;ImportImageFilter&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>point set</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkPointSet.h&quot;</span></span></span><br><span class="line"><span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Then we must decide what type of value to associate with the</span></span><br><span class="line">  <span class="comment">//  points. This is generally called the \code&#123;PixelType&#125; in order to make</span></span><br><span class="line">  <span class="comment">//  the terminology consistent with the \code&#123;itk::Image&#125;. The PointSet is</span></span><br><span class="line">  <span class="comment">//  also templated over the dimension of the space in which the points are</span></span><br><span class="line">  <span class="comment">//  represented. The following declaration illustrates a typical</span></span><br><span class="line">  <span class="comment">//  instantiation of the PointSet class.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!Instantiation&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointSetType = itk::PointSet&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>, <span class="number">3</span>&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  A \code&#123;PointSet&#125; object is created by invoking the \code&#123;New()&#125; method</span></span><br><span class="line">  <span class="comment">//  on its type.  The resulting object must be assigned to a</span></span><br><span class="line">  <span class="comment">//  \code&#123;SmartPointer&#125;.  The PointSet is then reference-counted and can be</span></span><br><span class="line">  <span class="comment">//  shared by multiple objects. The memory allocated for the PointSet will</span></span><br><span class="line">  <span class="comment">//  be released when the number of references to the object is reduced to</span></span><br><span class="line">  <span class="comment">//  zero. This simply means that the user does not need to be concerned</span></span><br><span class="line">  <span class="comment">//  with invoking the \code&#123;Delete()&#125; method on this class.  In fact, the</span></span><br><span class="line">  <span class="comment">//  \code&#123;Delete()&#125; method should \textbf&#123;never&#125; be called directly within</span></span><br><span class="line">  <span class="comment">//  any of the reference-counted ITK classes.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!New()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!Pointer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointSetType::Pointer pointsSet = PointSetType::<span class="built_in">New</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Following the principles of Generic Programming, the \code&#123;PointSet&#125;</span></span><br><span class="line">  <span class="comment">//  class has a set of associated defined types to ensure that interacting</span></span><br><span class="line">  <span class="comment">//  objects can be declared with compatible types. This set of type</span></span><br><span class="line">  <span class="comment">//  definitions is commonly known as a set of \emph&#123;traits&#125;.  Among the</span></span><br><span class="line">  <span class="comment">//  traits of the \code&#123;PointSet&#125; class is \code&#123;PointType&#125;, which is used</span></span><br><span class="line">  <span class="comment">//  by the point set to represent points in space. The following declaration</span></span><br><span class="line">  <span class="comment">//  takes the point type as defined in the \code&#123;PointSet&#125; traits and</span></span><br><span class="line">  <span class="comment">//  renames it to be conveniently used in the global namespace.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!PointType&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointType = PointSetType::PointType;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;PointType&#125; can now be used to declare point objects to be</span></span><br><span class="line">  <span class="comment">//  inserted in the \code&#123;PointSet&#125;. Points are fairly small objects, so</span></span><br><span class="line">  <span class="comment">//  it is inconvenient to manage them with reference counting and smart</span></span><br><span class="line">  <span class="comment">//  pointers. They are simply instantiated as typical C++ classes. The Point</span></span><br><span class="line">  <span class="comment">//  class inherits the \code&#123;[]&#125; operator from the \code&#123;itk::Array&#125; class.</span></span><br><span class="line">  <span class="comment">//  This makes it possible to access its components using index notation.</span></span><br><span class="line">  <span class="comment">//  For efficiency&#x27;s sake no bounds checking is performed during index</span></span><br><span class="line">  <span class="comment">//  access. It is the user&#x27;s responsibility to ensure that the index used is</span></span><br><span class="line">  <span class="comment">//  in the range</span></span><br><span class="line">  <span class="comment">//  $\&#123;0,Dimension-1\&#125;$. Each of the components in the point is associated</span></span><br><span class="line">  <span class="comment">//  with space coordinates. The following code illustrates how to</span></span><br><span class="line">  <span class="comment">//  instantiate a point and initialize its components.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointType p0;</span><br><span class="line">  p0[<span class="number">0</span>] = <span class="number">-1.0</span>; <span class="comment">//  x coordinate</span></span><br><span class="line">  p0[<span class="number">1</span>] = <span class="number">-1.0</span>; <span class="comment">//  y coordinate</span></span><br><span class="line">  p0[<span class="number">2</span>] = <span class="number">0.0</span>;  <span class="comment">//  z coordinate</span></span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PointType p1;</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">0</span>] = <span class="number">1.0</span>; <span class="comment">// Point 1 = &#123; 1,-1,0 &#125;</span></span><br><span class="line">  p1[<span class="number">1</span>] = <span class="number">-1.0</span>;</span><br><span class="line">  p1[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  PointType p2; <span class="comment">// Point 2 = &#123; 1,1,0 &#125;</span></span><br><span class="line">  p2[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">  p2[<span class="number">1</span>] = <span class="number">1.0</span>;</span><br><span class="line">  p2[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Points are inserted in the PointSet by using the \code&#123;SetPoint()&#125;</span></span><br><span class="line">  <span class="comment">//  method. This method requires the user to provide a unique identifier for</span></span><br><span class="line">  <span class="comment">//  the point. The identifier is typically an unsigned integer that will</span></span><br><span class="line">  <span class="comment">//  enumerate the points as they are being inserted. The following code</span></span><br><span class="line">  <span class="comment">//  shows how three points are inserted into the PointSet.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPoint()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  pointsSet-&gt;<span class="built_in">SetPoint</span>(<span class="number">0</span>, p0);</span><br><span class="line">  pointsSet-&gt;<span class="built_in">SetPoint</span>(<span class="number">1</span>, p1);</span><br><span class="line">  pointsSet-&gt;<span class="built_in">SetPoint</span>(<span class="number">2</span>, p2);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// It is possible to query the PointSet in order to determine how many</span></span><br><span class="line">  <span class="comment">// points have been inserted into it. This is done with the</span></span><br><span class="line">  <span class="comment">// \code&#123;GetNumberOfPoints()&#125; method as illustrated below.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetNumberOfPoints()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> numberOfPoints = pointsSet-&gt;<span class="built_in">GetNumberOfPoints</span>();</span><br><span class="line">  std::cout &lt;&lt; numberOfPoints &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Points can be read from the PointSet by using the \code&#123;GetPoint()&#125;</span></span><br><span class="line">  <span class="comment">// method and the integer identifier. The point is stored in a pointer</span></span><br><span class="line">  <span class="comment">// provided by the user. If the identifier provided does not match an</span></span><br><span class="line">  <span class="comment">// existing point, the method will return \code&#123;false&#125; and the contents of</span></span><br><span class="line">  <span class="comment">// the point will be invalid. The following code illustrates point access</span></span><br><span class="line">  <span class="comment">// using defensive programming.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPoint()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointType pp;</span><br><span class="line">  <span class="keyword">bool</span>      pointExists = pointsSet-&gt;<span class="built_in">GetPoint</span>(<span class="number">1</span>, &amp;pp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pointExists)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Point is = &quot;</span> &lt;&lt; pp &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \code&#123;GetPoint()&#125; and \code&#123;SetPoint()&#125; are not the most efficient</span></span><br><span class="line">  <span class="comment">// methods to access points in the PointSet. It is preferable to get direct</span></span><br><span class="line">  <span class="comment">// access to the internal point container defined by the \emph&#123;traits&#125; and</span></span><br><span class="line">  <span class="comment">// use iterators to walk sequentially over the list of points (as shown in</span></span><br><span class="line">  <span class="comment">// the following example).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过迭代器访问<code>pointsset</code>中的points容器（保存了点的位置信息）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=========================================================================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright NumFOCUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> *  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         http://www.apache.org/licenses/LICENSE-2.0.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *  limitations under the License.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *=========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  The \doxygen&#123;PointSet&#125; class uses an internal container to manage the</span></span><br><span class="line"><span class="comment">//  storage of \doxygen&#123;Point&#125;s. It is more efficient, in general, to manage</span></span><br><span class="line"><span class="comment">//  points by using the access methods provided directly on the points</span></span><br><span class="line"><span class="comment">//  container. The following example illustrates how to interact with the</span></span><br><span class="line"><span class="comment">//  point container and how to use point iterators.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkPointSet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> PointSetType = itk::PointSet&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>, <span class="number">3</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The type is defined by the \emph&#123;traits&#125; of the \code&#123;PointSet&#125;</span></span><br><span class="line">  <span class="comment">//  class. The following line conveniently takes the \code&#123;PointsContainer&#125;</span></span><br><span class="line">  <span class="comment">//  type from the \code&#123;PointSet&#125; traits and declares it in the global</span></span><br><span class="line">  <span class="comment">//  namespace.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!PointsContainer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointsContainer = PointSetType::PointsContainer;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The actual type of \code&#123;PointsContainer&#125; depends on what style of</span></span><br><span class="line">  <span class="comment">//  \code&#123;PointSet&#125; is being used. The dynamic \code&#123;PointSet&#125; uses</span></span><br><span class="line">  <span class="comment">//  \doxygen&#123;MapContainer&#125; while the static \code&#123;PointSet&#125; uses</span></span><br><span class="line">  <span class="comment">//  \doxygen&#123;VectorContainer&#125;. The vector and map containers are basically</span></span><br><span class="line">  <span class="comment">//  ITK wrappers around the \href&#123;http://www.sgi.com/tech/stl/&#125;&#123;STL&#125;</span></span><br><span class="line">  <span class="comment">//  classes \href&#123;http://www.sgi.com/tech/stl/Map.html&#125;&#123;\code&#123;std::map&#125;&#125;</span></span><br><span class="line">  <span class="comment">//  and \href&#123;http://www.sgi.com/tech/stl/Vector.html&#125;&#123;\code&#123;std::vector&#125;&#125;.</span></span><br><span class="line">  <span class="comment">//  By default, \code&#123;PointSet&#125; uses a static style, and therefore the</span></span><br><span class="line">  <span class="comment">//  default type of point container is \code&#123;VectorContainer&#125;.  Both map and</span></span><br><span class="line">  <span class="comment">//  vector containers are templated over the type of element they contain.</span></span><br><span class="line">  <span class="comment">//  In this case they are templated over \code&#123;PointType&#125;. Containers are</span></span><br><span class="line">  <span class="comment">//  reference counted objects, created with the \code&#123;New()&#125; method and</span></span><br><span class="line">  <span class="comment">//  assigned to a \doxygen&#123;SmartPointer&#125;. The following line creates a point</span></span><br><span class="line">  <span class="comment">//  container compatible with the type of the \code&#123;PointSet&#125; from which the</span></span><br><span class="line">  <span class="comment">//  trait has been taken.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!New()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Pointer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointsContainer::Pointer points = PointsContainer::<span class="built_in">New</span>();<span class="comment">//points是点集</span></span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \code&#123;Point&#125;s can now be defined using the \code&#123;PointType&#125; trait from</span></span><br><span class="line">  <span class="comment">//  the \code&#123;PointSet&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointType = PointSetType::PointType;</span><br><span class="line">  PointType p0;</span><br><span class="line">  PointType p1;</span><br><span class="line">  p0[<span class="number">0</span>] = <span class="number">-1.0</span>;</span><br><span class="line">  p0[<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">  p0[<span class="number">2</span>] = <span class="number">0.0</span>; <span class="comment">// Point 0 = &#123;-1,0,0 &#125;</span></span><br><span class="line">  p1[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">  p1[<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">  p1[<span class="number">2</span>] = <span class="number">0.0</span>; <span class="comment">// Point 1 = &#123; 1,0,0 &#125;</span></span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line">  <span class="comment">// point类型就是数组保存三个位置的参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The created points can be inserted in the \code&#123;PointsContainer&#125; using</span></span><br><span class="line">  <span class="comment">//  the generic method \code&#123;InsertElement()&#125; which requires an identifier</span></span><br><span class="line">  <span class="comment">//  to be provided for each point.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::VectorContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::MapContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> pointId = <span class="number">0</span>;</span><br><span class="line">  points-&gt;<span class="built_in">InsertElement</span>(pointId++, p0);</span><br><span class="line">  points-&gt;<span class="built_in">InsertElement</span>(pointId++, p1);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  PointSetType::Pointer pointSet = PointSetType::<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Finally, the \code&#123;PointsContainer&#125; can be assigned to the</span></span><br><span class="line">  <span class="comment">//  \code&#123;PointSet&#125;. This will substitute any previously existing</span></span><br><span class="line">  <span class="comment">//  \code&#123;PointsContainer&#125; assigned to the \code&#123;PointSet&#125;. The assignment</span></span><br><span class="line">  <span class="comment">//  is done using the \code&#123;SetPoints()&#125; method.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPoints()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  pointSet-&gt;<span class="built_in">SetPoints</span>(points);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;PointsContainer&#125; object can be obtained from the</span></span><br><span class="line">  <span class="comment">//  \code&#123;PointSet&#125; using the \code&#123;GetPoints()&#125; method.  This method</span></span><br><span class="line">  <span class="comment">//  returns a pointer to the actual container owned by the PointSet which is</span></span><br><span class="line">  <span class="comment">//  then assigned to a \code&#123;SmartPointer&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPoints()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Pointer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointsContainer::Pointer points2 = pointSet-&gt;<span class="built_in">GetPoints</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The most efficient way to sequentially visit the points is to use the</span></span><br><span class="line">  <span class="comment">//  iterators provided by PointsContainer. The \code&#123;Iterator&#125; type belongs</span></span><br><span class="line">  <span class="comment">//  to the traits of the PointsContainer classes. It behaves pretty much</span></span><br><span class="line">  <span class="comment">//  like the STL iterators.\footnote&#123;If you dig deep enough into the code,</span></span><br><span class="line">  <span class="comment">//  you will discover that these iterators are actually ITK wrappers around</span></span><br><span class="line">  <span class="comment">//  STL iterators.&#125;  The Points iterator is not a reference counted class,</span></span><br><span class="line">  <span class="comment">//  so it is created directly from the traits without using SmartPointers.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Iterator&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointsIterator = PointsContainer::Iterator;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The subsequent use of the iterator follows what you may expect from a</span></span><br><span class="line">  <span class="comment">//  STL iterator. The iterator to the first point is obtained from the</span></span><br><span class="line">  <span class="comment">//  container with the \code&#123;Begin()&#125; method and assigned to another</span></span><br><span class="line">  <span class="comment">//  iterator.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Begin()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointsIterator pointIterator = points-&gt;<span class="built_in">Begin</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;++&#125; operator on the iterator can be used to advance from one</span></span><br><span class="line">  <span class="comment">//  point to the next. The actual value of the Point to which the iterator</span></span><br><span class="line">  <span class="comment">//  is pointing can be obtained with the \code&#123;Value()&#125; method. The loop for</span></span><br><span class="line">  <span class="comment">//  walking through all the points can be controlled by comparing the</span></span><br><span class="line">  <span class="comment">//  current iterator with the iterator returned by the \code&#123;End()&#125; method</span></span><br><span class="line">  <span class="comment">//  of the PointsContainer. The following lines illustrate the typical loop</span></span><br><span class="line">  <span class="comment">//  for walking through the points.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!End()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Iterator&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointsIterator end = points-&gt;<span class="built_in">End</span>();</span><br><span class="line">  <span class="keyword">while</span> (pointIterator != end)</span><br><span class="line">  &#123;</span><br><span class="line">    PointType p = pointIterator.<span class="built_in">Value</span>(); <span class="comment">// access the point</span></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;         <span class="comment">// print the point</span></span><br><span class="line">    ++pointIterator;                     <span class="comment">// advance to next point</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Note that as in STL, the iterator returned by the \code&#123;End()&#125; method is</span></span><br><span class="line">  <span class="comment">//  not a valid iterator. This is called a past-end iterator in order to</span></span><br><span class="line">  <span class="comment">//  indicate that it is the value resulting from advancing one step after</span></span><br><span class="line">  <span class="comment">//  visiting the last element in the container.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The number of elements stored in a container can be queried with the</span></span><br><span class="line">  <span class="comment">//  \code&#123;Size()&#125; method. In the case of the PointSet, the following two</span></span><br><span class="line">  <span class="comment">//  lines of code are equivalent, both of them returning the number of</span></span><br><span class="line">  <span class="comment">//  points in the PointSet.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetNumberOfPoints()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPoints()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointsContainer!Size()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  std::cout &lt;&lt; pointSet-&gt;<span class="built_in">GetNumberOfPoints</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">Size</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改变点的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=========================================================================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright NumFOCUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> *  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         http://www.apache.org/licenses/LICENSE-2.0.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *  limitations under the License.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *=========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  The \doxygen&#123;PointSet&#125; class was designed to interact with the</span></span><br><span class="line"><span class="comment">//  \code&#123;Image&#125; class. For this reason it was found convenient to allow the</span></span><br><span class="line"><span class="comment">//  points in the set to hold values that could be computed from images. The</span></span><br><span class="line"><span class="comment">//  value associated with the point is referred as \code&#123;PixelType&#125; in order</span></span><br><span class="line"><span class="comment">//  to make it consistent with image terminology. Users can define the type as</span></span><br><span class="line"><span class="comment">//  they please thanks to the flexibility offered by the Generic Programming</span></span><br><span class="line"><span class="comment">//  approach used in the toolkit.  The \code&#123;PixelType&#125; is the first template</span></span><br><span class="line"><span class="comment">//  parameter of the PointSet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  \index&#123;itk::PointSet!PixelType&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkPointSet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The following code defines a particular type for a pixel type and</span></span><br><span class="line">  <span class="comment">//  instantiates a PointSet class with it.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PixelType = <span class="keyword">unsigned</span> <span class="keyword">short</span>; <span class="comment">//注意pixeltype从才是点的数据类型，PointType是点的位置</span></span><br><span class="line">  <span class="keyword">using</span> PointSetType = itk::PointSet&lt;PixelType, <span class="number">3</span>&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A point set is instantiated here</span></span><br><span class="line">  PointSetType::Pointer pointSet = PointSetType::<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Data can be inserted into the PointSet using the \code&#123;SetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//  method. This method requires the user to provide an identifier. The data</span></span><br><span class="line">  <span class="comment">//  in question will be associated to the point holding the same identifier.</span></span><br><span class="line">  <span class="comment">//  It is the user&#x27;s responsibility to verify the appropriate matching</span></span><br><span class="line">  <span class="comment">//  between inserted data and inserted points. The following line</span></span><br><span class="line">  <span class="comment">//  illustrates the use of the \code&#123;SetPointData()&#125; method.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> dataId = <span class="number">0</span>;</span><br><span class="line">  PixelType    value = <span class="number">79</span>;</span><br><span class="line">  pointSet-&gt;<span class="built_in">SetPointData</span>(dataId++, value);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Data associated with points can be read from the PointSet using the</span></span><br><span class="line">  <span class="comment">//  \code&#123;GetPointData()&#125; method. This method requires the user to provide</span></span><br><span class="line">  <span class="comment">//  the identifier to the point and a valid pointer to a location where the</span></span><br><span class="line">  <span class="comment">//  pixel data can be safely written. In case the identifier does not match</span></span><br><span class="line">  <span class="comment">//  any existing identifier on the PointSet the method will return</span></span><br><span class="line">  <span class="comment">//  \code&#123;false&#125; and the pixel value returned will be invalid. It is the</span></span><br><span class="line">  <span class="comment">//  user&#x27;s responsibility to check the returned boolean value before</span></span><br><span class="line">  <span class="comment">//  attempting to use it.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> found = pointSet-&gt;<span class="built_in">GetPointData</span>(dataId, &amp;value);</span><br><span class="line">  <span class="keyword">if</span> (found)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pixel value = &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;SetPointData()&#125; and \code&#123;GetPointData()&#125; methods are not the</span></span><br><span class="line">  <span class="comment">//  most efficient way to get access to point data. It is far more efficient</span></span><br><span class="line">  <span class="comment">//  to use the Iterators provided by the \code&#123;PointDataContainer&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Data associated with points is internally stored in</span></span><br><span class="line">  <span class="comment">//  \code&#123;PointDataContainer&#125;s.  In the same way as with points, the actual</span></span><br><span class="line">  <span class="comment">//  container type used depend on whether the style of the PointSet is</span></span><br><span class="line">  <span class="comment">//  static or dynamic. Static point sets will use an</span></span><br><span class="line">  <span class="comment">//  \doxygen&#123;VectorContainer&#125; while dynamic point sets will use an</span></span><br><span class="line">  <span class="comment">//  \doxygen&#123;MapContainer&#125;.  The type of the data container is defined as</span></span><br><span class="line">  <span class="comment">//  one of the traits in the PointSet. The following declaration illustrates</span></span><br><span class="line">  <span class="comment">//  how the type can be taken from the traits and used to conveniently</span></span><br><span class="line">  <span class="comment">//  declare a similar type on the global namespace.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!PointDataContainer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointDataContainer = PointSetType::PointDataContainer;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Using the type it is now possible to create an instance of the data</span></span><br><span class="line">  <span class="comment">//  container. This is a standard reference counted object, henceforth it</span></span><br><span class="line">  <span class="comment">//  uses the \code&#123;New()&#125; method for creation and assigns the newly created</span></span><br><span class="line">  <span class="comment">//  object to a SmartPointer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!New()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!Pointer&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointDataContainer::Pointer pointData = PointDataContainer::<span class="built_in">New</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Pixel data can be inserted in the container with the method</span></span><br><span class="line">  <span class="comment">//  \code&#123;InsertElement()&#125;. This method requires an identified to be</span></span><br><span class="line">  <span class="comment">//  provided for each point data.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::VectorContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::MapContainer!InsertElement()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> pointId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  PixelType value0 = <span class="number">34</span>;</span><br><span class="line">  PixelType value1 = <span class="number">67</span>;</span><br><span class="line"></span><br><span class="line">  pointData-&gt;<span class="built_in">InsertElement</span>(pointId++, value0);</span><br><span class="line">  pointData-&gt;<span class="built_in">InsertElement</span>(pointId++, value1);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Finally the PointDataContainer can be assigned to the PointSet. This</span></span><br><span class="line">  <span class="comment">//  will substitute any previously existing PointDataContainer on the</span></span><br><span class="line">  <span class="comment">//  PointSet. The assignment is done using the \code&#123;SetPointData()&#125; method.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  pointSet-&gt;<span class="built_in">SetPointData</span>(pointData);</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The PointDataContainer can be obtained from the PointSet using the</span></span><br><span class="line">  <span class="comment">//  \code&#123;GetPointData()&#125; method.  This method returns a pointer (assigned</span></span><br><span class="line">  <span class="comment">//  to a SmartPointer) to the actual container owned by the PointSet.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointDataContainer::Pointer pointData2 = pointSet-&gt;<span class="built_in">GetPointData</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The most efficient way to sequentially visit the data associated with</span></span><br><span class="line">  <span class="comment">//  points is to use the iterators provided by \code&#123;PointDataContainer&#125;.</span></span><br><span class="line">  <span class="comment">//  The \code&#123;Iterator&#125; type belongs to the traits of the PointsContainer</span></span><br><span class="line">  <span class="comment">//  classes. The iterator is not a reference counted class, so it is just</span></span><br><span class="line">  <span class="comment">//  created directly from the traits without using SmartPointers.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!Iterator&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointDataIterator = PointDataContainer::Iterator;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The subsequent use of the iterator follows what you may expect from a</span></span><br><span class="line">  <span class="comment">//  STL iterator. The iterator to the first point is obtained from the</span></span><br><span class="line">  <span class="comment">//  container with the \code&#123;Begin()&#125; method and assigned to another</span></span><br><span class="line">  <span class="comment">//  iterator.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!Begin()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointDataIterator pointDataIterator = pointData2-&gt;<span class="built_in">Begin</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;++&#125; operator on the iterator can be used to advance from one</span></span><br><span class="line">  <span class="comment">//  data point to the next. The actual value of the PixelType to which the</span></span><br><span class="line">  <span class="comment">//  iterator is pointing can be obtained with the \code&#123;Value()&#125;</span></span><br><span class="line">  <span class="comment">//  method. The loop for walking through all the point data can be</span></span><br><span class="line">  <span class="comment">//  controlled by comparing the current iterator with the iterator returned</span></span><br><span class="line">  <span class="comment">//  by the \code&#123;End()&#125; method of the PointsContainer. The following lines</span></span><br><span class="line">  <span class="comment">//  illustrate the typical loop for walking through the point data.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!End()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;PointDataContainer!increment ++&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointDataIterator end = pointData2-&gt;<span class="built_in">End</span>();</span><br><span class="line">  <span class="keyword">while</span> (pointDataIterator != end)</span><br><span class="line">  &#123;</span><br><span class="line">    PixelType p = pointDataIterator.<span class="built_in">Value</span>(); <span class="comment">// access the pixel data</span></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;             <span class="comment">// print the pixel data</span></span><br><span class="line">    ++pointDataIterator;                     <span class="comment">// advance to next pixel/point</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Note that as in STL, the iterator returned by the \code&#123;End()&#125; method is</span></span><br><span class="line">  <span class="comment">//  not a valid iterator. This is called a \emph&#123;past-end&#125; iterator in order</span></span><br><span class="line">  <span class="comment">//  to indicate that it is the value resulting from advancing one step after</span></span><br><span class="line">  <span class="comment">//  visiting the last element in the container.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用RGB作为<code>PixelType</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkRGBPixel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkPointSet.h&quot;</span></span></span><br><span class="line"><span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Then, the pixel type can be defined by selecting the type to be used to</span></span><br><span class="line">  <span class="comment">//  represent each one of the RGB components.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::RGBPixel!Instantiation&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PixelType = itk::RGBPixel&lt;<span class="keyword">float</span>&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The newly defined pixel type is now used to instantiate the PointSet</span></span><br><span class="line">  <span class="comment">//  type and subsequently create a point set object.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointSetType = itk::PointSet&lt;PixelType, <span class="number">3</span>&gt;;</span><br><span class="line">  PointSetType::Pointer pointSet = PointSetType::<span class="built_in">New</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The following code generates a circle and assigns RGB values to</span></span><br><span class="line">  <span class="comment">//  the points. The components of the RGB values in this example are</span></span><br><span class="line">  <span class="comment">//  computed to represent the position of the points.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPoint()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointSetType::PixelType pixel; <span class="comment">//点的值</span></span><br><span class="line">  PointSetType::PointType point; <span class="comment">//点的位置</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>            pointId = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">double</span>        radius = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> angle = i * itk::Math::pi / <span class="number">180.0</span>;</span><br><span class="line">    point[<span class="number">0</span>] = radius * std::<span class="built_in">sin</span>(angle);</span><br><span class="line">    point[<span class="number">1</span>] = radius * std::<span class="built_in">cos</span>(angle);</span><br><span class="line">    point[<span class="number">2</span>] = <span class="number">1.0</span>;</span><br><span class="line">    pixel.<span class="built_in">SetRed</span>(point[<span class="number">0</span>] * <span class="number">2.0</span>);</span><br><span class="line">    pixel.<span class="built_in">SetGreen</span>(point[<span class="number">1</span>] * <span class="number">2.0</span>);</span><br><span class="line">    pixel.<span class="built_in">SetBlue</span>(point[<span class="number">2</span>] * <span class="number">2.0</span>);</span><br><span class="line">    pointSet-&gt;<span class="built_in">SetPoint</span>(pointId, point);</span><br><span class="line">    pointSet-&gt;<span class="built_in">SetPointData</span>(pointId, pixel);</span><br><span class="line">    pointId++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  All the points on the PointSet are visited using the following code.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPoints()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!points iterator&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!iterating points&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointIterator = PointSetType::PointsContainer::ConstIterator;</span><br><span class="line">  PointIterator pointIterator = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">Begin</span>();<span class="comment">//获得点集的容器</span></span><br><span class="line">  PointIterator pointEnd = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">End</span>();</span><br><span class="line">  <span class="keyword">while</span> (pointIterator != pointEnd)</span><br><span class="line">  &#123;</span><br><span class="line">    point = pointIterator.<span class="built_in">Value</span>();</span><br><span class="line">    std::cout &lt;&lt; point &lt;&lt; std::endl;</span><br><span class="line">    ++pointIterator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Note that here the \code&#123;ConstIterator&#125; was used instead of the</span></span><br><span class="line">  <span class="comment">//  \code&#123;Iterator&#125; since the pixel values are not expected to be modified.</span></span><br><span class="line">  <span class="comment">//  ITK supports const-correctness at the API level.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  All the pixel values on the PointSet are visited using the following</span></span><br><span class="line">  <span class="comment">//  code.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!data iterator&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!iterating point data&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointDataIterator = PointSetType::PointDataContainer::ConstIterator;</span><br><span class="line">  PointDataIterator pixelIterator = pointSet-&gt;<span class="built_in">GetPointData</span>()-&gt;<span class="built_in">Begin</span>();<span class="comment">//获得点值的容器</span></span><br><span class="line">  PointDataIterator pixelEnd = pointSet-&gt;<span class="built_in">GetPointData</span>()-&gt;<span class="built_in">End</span>();</span><br><span class="line">  <span class="keyword">while</span> (pixelIterator != pixelEnd)</span><br><span class="line">  &#123;</span><br><span class="line">    pixel = pixelIterator.<span class="built_in">Value</span>();</span><br><span class="line">    std::cout &lt;&lt; pixel &lt;&lt; std::endl;</span><br><span class="line">    ++pixelIterator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Again, please note the use of the  \code&#123;ConstIterator&#125; instead of the</span></span><br><span class="line">  <span class="comment">//  \code&#123;Iterator&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;ConstIterator&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;const-correctness&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vector作为PixelType</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=========================================================================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright NumFOCUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> *  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         http://www.apache.org/licenses/LICENSE-2.0.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *  limitations under the License.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *=========================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This example illustrates how a point set can be parameterized to manage a</span></span><br><span class="line"><span class="comment">//  particular pixel type. It is quite common to associate vector values with</span></span><br><span class="line"><span class="comment">//  points for producing geometric representations.  The following code shows</span></span><br><span class="line"><span class="comment">//  how vector values can be used as the pixel type on the PointSet class. The</span></span><br><span class="line"><span class="comment">//  \doxygen&#123;Vector&#125; class is used here as the pixel type. This class is</span></span><br><span class="line"><span class="comment">//  appropriate for representing the relative position between two points. It</span></span><br><span class="line"><span class="comment">//  could then be used to manage displacements, for example.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  \index&#123;itk::PointSet!Vector pixels&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  In order to use the vector class it is necessary to include its header</span></span><br><span class="line"><span class="comment">//  file along with the header of the point set.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkVector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;itkPointSet.h&quot;</span></span></span><br><span class="line"><span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="built_in">main</span>(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \begin&#123;floatingfigure&#125;[rlp]&#123;6cm&#125;</span></span><br><span class="line">  <span class="comment">//    \centering</span></span><br><span class="line">  <span class="comment">//    \includegraphics[width=4cm]&#123;PointSetWithVectors&#125;</span></span><br><span class="line">  <span class="comment">//    \caption[PointSet with Vectors as PixelType]&#123;Vectors as</span></span><br><span class="line">  <span class="comment">//    PixelType.\label&#123;fig:PointSetWithVectors&#125;&#125;</span></span><br><span class="line">  <span class="comment">//  \end&#123;floatingfigure&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \code&#123;Vector&#125; class is templated over the type used to represent</span></span><br><span class="line">  <span class="comment">//  the spatial coordinates and over the space dimension.  Since the</span></span><br><span class="line">  <span class="comment">//  PixelType is independent of the PointType, we are free to select any</span></span><br><span class="line">  <span class="comment">//  dimension for the vectors to be used as pixel type. However, for the</span></span><br><span class="line">  <span class="comment">//  sake of producing an interesting example, we will use vectors that</span></span><br><span class="line">  <span class="comment">//  represent displacements of the points in the PointSet. Those vectors</span></span><br><span class="line">  <span class="comment">//  are then selected to be of the same dimension as the PointSet.\newline</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::Vector!itk::PointSet&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Dimension = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">using</span> PixelType = itk::Vector&lt;<span class="keyword">float</span>, Dimension&gt;;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Then we use the PixelType (which are actually Vectors) to instantiate</span></span><br><span class="line">  <span class="comment">//  the PointSet type and subsequently create a PointSet object.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointSetType = itk::PointSet&lt;PixelType, Dimension&gt;;</span><br><span class="line">  PointSetType::Pointer pointSet = PointSetType::<span class="built_in">New</span>();</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The following code is generating a sphere and assigning vector values</span></span><br><span class="line">  <span class="comment">//  to the points. The components of the vectors in this example are</span></span><br><span class="line">  <span class="comment">//  computed to represent the tangents to the circle as shown in</span></span><br><span class="line">  <span class="comment">//  Figure~\ref&#123;fig:PointSetWithVectors&#125;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPoint()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!SetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  PointSetType::PixelType tangent;</span><br><span class="line">  PointSetType::PointType point;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>     pointId = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">double</span> radius = <span class="number">300.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> angle = i * itk::Math::pi / <span class="number">180.0</span>;</span><br><span class="line">    point[<span class="number">0</span>] = radius * std::<span class="built_in">sin</span>(angle);</span><br><span class="line">    point[<span class="number">1</span>] = radius * std::<span class="built_in">cos</span>(angle);</span><br><span class="line">    point[<span class="number">2</span>] = <span class="number">1.0</span>; <span class="comment">// flat on the Z plane</span></span><br><span class="line">    tangent[<span class="number">0</span>] = std::<span class="built_in">cos</span>(angle);</span><br><span class="line">    tangent[<span class="number">1</span>] = -std::<span class="built_in">sin</span>(angle);</span><br><span class="line">    tangent[<span class="number">2</span>] = <span class="number">0.0</span>; <span class="comment">// flat on the Z plane</span></span><br><span class="line">    pointSet-&gt;<span class="built_in">SetPoint</span>(pointId, point);</span><br><span class="line">    pointSet-&gt;<span class="built_in">SetPointData</span>(pointId, tangent);</span><br><span class="line">    pointId++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  We can now visit all the points and use the vector on the pixel values</span></span><br><span class="line">  <span class="comment">//  to apply a displacement on the points. This is along the spirit of what</span></span><br><span class="line">  <span class="comment">//  a deformable model could do at each one of its iterations.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!PointIterator&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPoints()&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!GetPointData()&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  <span class="keyword">using</span> PointDataIterator = PointSetType::PointDataContainer::ConstIterator;</span><br><span class="line">  PointDataIterator pixelIterator = pointSet-&gt;<span class="built_in">GetPointData</span>()-&gt;<span class="built_in">Begin</span>();</span><br><span class="line">  PointDataIterator pixelEnd = pointSet-&gt;<span class="built_in">GetPointData</span>()-&gt;<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> PointIterator = PointSetType::PointsContainer::Iterator;</span><br><span class="line">  PointIterator pointIterator = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">Begin</span>();</span><br><span class="line">  PointIterator pointEnd = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (pixelIterator != pixelEnd &amp;&amp; pointIterator != pointEnd)</span><br><span class="line">  &#123;</span><br><span class="line">    pointIterator.<span class="built_in">Value</span>() = pointIterator.<span class="built_in">Value</span>() + pixelIterator.<span class="built_in">Value</span>();</span><br><span class="line">    ++pixelIterator;</span><br><span class="line">    ++pointIterator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Note that the \code&#123;ConstIterator&#125; was used here instead of the normal</span></span><br><span class="line">  <span class="comment">//  \code&#123;Iterator&#125; since the pixel values are only intended to be read and</span></span><br><span class="line">  <span class="comment">//  not modified. ITK supports const-correctness at the API level.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;ConstIterator&#125;</span></span><br><span class="line">  <span class="comment">//  \index&#123;const-correctness&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  The \doxygen&#123;Vector&#125; class has overloaded the \code&#123;+&#125; operator with</span></span><br><span class="line">  <span class="comment">//  the \doxygen&#123;Point&#125;. In other words, vectors can be added to points in</span></span><br><span class="line">  <span class="comment">//  order to produce new points.  This property is exploited in the center</span></span><br><span class="line">  <span class="comment">//  of the loop in order to update the points positions with a single</span></span><br><span class="line">  <span class="comment">//  statement.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  \index&#123;itk::PointSet!PointIterator&#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  We can finally visit all the points and print out the new values</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Software Guide : BeginCodeSnippet</span></span><br><span class="line">  pointIterator = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">Begin</span>();</span><br><span class="line">  pointEnd = pointSet-&gt;<span class="built_in">GetPoints</span>()-&gt;<span class="built_in">End</span>();</span><br><span class="line">  <span class="keyword">while</span> (pointIterator != pointEnd)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; pointIterator.<span class="built_in">Value</span>() &lt;&lt; std::endl;</span><br><span class="line">    ++pointIterator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Software Guide : EndCodeSnippet</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Software Guide : BeginLatex</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Note that \doxygen&#123;Vector&#125; is not the appropriate class for</span></span><br><span class="line">  <span class="comment">//  representing normals to surfaces and gradients of functions. This is due</span></span><br><span class="line">  <span class="comment">//  to the way vectors behave under affine transforms. ITK has a</span></span><br><span class="line">  <span class="comment">//  specific class for representing normals and function gradients. This is</span></span><br><span class="line">  <span class="comment">//  the \doxygen&#123;CovariantVector&#125; class.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Software Guide : EndLatex</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Itk</tag>
        <tag>医学图像处理</tag>
      </tags>
  </entry>
</search>
